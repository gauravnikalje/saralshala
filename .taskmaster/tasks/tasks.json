{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Development Environment and Project Structure",
        "description": "Initialize the project with the specified technology stack and establish the basic file structure.",
        "details": "1.  Set up a Supabase project. 2.  Initialize a new project using HTML, CSS, JavaScript, Tailwind CSS (via CDN), and Alpine.js. 3.  Create the basic file structure (e.g., `index.html`, `styles.css`, `script.js`, and folders for components, pages, etc.). 4.  Configure Vercel/Netlify for frontend deployment.",
        "testStrategy": "Verify that the basic project structure is created and that the frontend can be deployed to Vercel/Netlify.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Database Schema",
            "description": "Define the database table structure for storing user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Include fields for `id`, `username` (unique), `email` (unique), `password_hash`, `salt`, `created_at`, `updated_at`, `is_active`. Consider indexing `username` and `email` for performance. Use appropriate data types for each field.",
            "status": "done",
            "testStrategy": "Review schema with team for completeness and correctness. Verify data types, constraints (e.g., unique, not null), and indexing. Create migration scripts and test their execution.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create a backend API endpoint to handle new user registrations, including data validation and secure password hashing.",
            "dependencies": [],
            "details": "Endpoint should be `POST /api/register`. Validate input fields (`username`, `email`, `password`) for format, length, and uniqueness. Hash password using a strong algorithm (e.g., bcrypt) with a generated salt. Store user data in the database. Return appropriate success/error responses.",
            "status": "done",
            "testStrategy": "Unit tests for input validation, password hashing, and database interaction. Integration tests for successful registration, duplicate username/email errors, and invalid input errors. Use tools like Postman or curl for manual API testing.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint",
            "description": "Create a backend API endpoint to authenticate users based on their username/email and password, issuing a JWT token upon success.",
            "dependencies": [],
            "details": "Endpoint should be `POST /api/login`. Retrieve user by username or email. Compare provided password with the stored hash using the correct salt. If credentials are valid, generate a JSON Web Token (JWT) containing user ID and roles, and return it. Handle invalid credentials gracefully.",
            "status": "done",
            "testStrategy": "Unit tests for password comparison logic and JWT generation. Integration tests for successful login, incorrect password, non-existent user, and token validity. Test token expiration and refresh mechanisms if implemented.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop Frontend Registration Form",
            "description": "Create a user interface component for new users to register an account, interacting with the registration API.",
            "dependencies": [],
            "details": "Design an HTML form with fields for username, email, password, and confirm password. Implement client-side validation for input format and password matching. On submission, send data to the `/api/register` endpoint. Display success messages or API error feedback to the user.",
            "status": "done",
            "testStrategy": "Manual testing for form submission, client-side validation, and display of API responses (success/error). Automated UI tests (e.g., Cypress, Playwright) to simulate user registration flow and verify UI updates.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Develop Frontend Login Form",
            "description": "Create a user interface component for existing users to log in, interacting with the login API and handling the JWT token.",
            "dependencies": [],
            "details": "Design an HTML form with fields for username/email and password. Implement client-side validation. On submission, send data to the `/api/login` endpoint. Upon successful login, store the received JWT token (e.g., in local storage) and redirect the user to a protected area of the application.",
            "status": "done",
            "testStrategy": "Manual testing for form submission, client-side validation, and correct handling of API responses (success/failure). Verify that the JWT token is stored correctly and that the user is redirected. Automated UI tests for login flow and token persistence.",
            "parentId": "undefined"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 5,
        "expansionPrompt": "No further expansion needed for this task as it is foundational and its subtasks are already well-defined and in progress."
      },
      {
        "id": 2,
        "title": "Implement User Authentication",
        "description": "Develop the user authentication system for teachers and the principal.",
        "details": "1.  Design and implement the login page with separate portals/redirects for Teacher and Principal. 2.  Integrate Supabase authentication for user login with unique ID and password. 3.  Implement password reset functionality (handled by Principal for MVP). 4.  Implement role-based access control (Teacher and Principal).",
        "testStrategy": "Test login functionality for both Teacher and Principal roles. Verify correct redirection to respective dashboards. Test password reset functionality.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Database Schema",
            "description": "Define the database table structure for storing user information, including fields for username, email, password hash, and roles.",
            "dependencies": [],
            "details": "Use SQL DDL to create a `users` table. Include columns for `id` (PK), `username` (unique), `email` (unique), `password_hash`, `created_at`, `updated_at`. Consider indexing `username` and `email` for performance.",
            "status": "done",
            "testStrategy": "Verify table creation and column definitions using a database client. Ensure unique constraints are enforced.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to register by providing a username, email, and password. The password should be hashed before storage.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Validate input fields (e.g., email format, password strength, uniqueness of username/email). Hash passwords using a strong algorithm like bcrypt. Store user data in the database.",
            "status": "done",
            "testStrategy": "Use Postman/cURL to send valid and invalid registration requests. Check database for new user entry and correct password hash. Test edge cases like existing username/email.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop JWT Generation and Verification Utility",
            "description": "Create a set of utility functions for generating, signing, and verifying JSON Web Tokens.",
            "dependencies": [],
            "details": "Use a library like `jsonwebtoken`. Define a secure secret key (e.g., from environment variables). Implement functions for `generateToken(payload, expiresIn)` and `verifyToken(token)`. The payload should include user ID and roles.",
            "status": "done",
            "testStrategy": "Unit tests for token generation with various payloads and expiration times. Unit tests for token verification with valid, invalid, and expired tokens. Ensure correct error handling for invalid tokens.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint (`/api/login`) that authenticates users based on their username/email and password, returning a JWT upon successful login.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Retrieve user from database by username/email. Compare provided password with stored hash. If valid, use the JWT utility to generate and return a token. Handle invalid credentials gracefully.",
            "status": "done",
            "testStrategy": "Use Postman/cURL to send valid and invalid login requests. Verify JWT generation and structure for valid logins. Test with incorrect passwords and non-existent users.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement JWT Authentication Middleware",
            "description": "Create a middleware function that protects API routes by verifying the presence and validity of a JWT in the request header.",
            "dependencies": [],
            "details": "Extract token from `Authorization: Bearer <token>` header. Use the `verifyToken` utility. If valid, attach user information (e.g., user ID, roles) to the request object. If invalid or missing, return a 401 Unauthorized response.",
            "status": "done",
            "testStrategy": "Create a dummy protected route. Test access with valid, invalid, expired, and missing JWTs. Verify that user information is correctly attached to the request for valid tokens.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement Protected User Profile Endpoint",
            "description": "Create a protected API endpoint (`/api/profile`) that returns the authenticated user's profile information.",
            "dependencies": [],
            "details": "Apply the JWT authentication middleware to this route. The endpoint should be a GET request. Fetch user details from the database using the user ID obtained from the verified token (attached by the middleware). Return relevant profile data.",
            "status": "done",
            "testStrategy": "Test access with a valid JWT (obtained from login). Test access without a JWT and with an invalid/expired JWT. Verify that the correct user data is returned for authenticated requests and that unauthorized requests are rejected.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand subtask 2.5 'Implement Principal-Managed Password Reset Functionality' to explicitly include the design and implementation of a secure backend function (e.g., Supabase Edge Function) to handle Supabase Admin API calls for password resets, ensuring no admin keys are exposed client-side. Also, add a new subtask for defining Supabase Row Level Security (RLS) policies for user roles to enforce access control at the database level."
      },
      {
        "id": 3,
        "title": "Develop Teacher Dashboard",
        "description": "Create the teacher dashboard to display relevant information and provide quick access to core features.",
        "details": "1.  Design the Teacher Dashboard UI based on the provided mockup. 2.  Fetch and display the teacher's current/next class from the timetable (data will be populated later). 3.  Implement a button to mark attendance. 4.  Display a list of recent unread notices. 5.  Include quick access buttons to other modules (Grades, Timetable).",
        "testStrategy": "Verify that the dashboard loads correctly, displays the correct schedule, and that the quick access buttons are functional.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for User Authentication",
            "description": "Define the database table structure required for storing user accounts, including fields for username, email, password hash, and roles.",
            "dependencies": [],
            "details": "Consider fields like `id (PK)`, `username (unique, string)`, `email (unique, string)`, `password_hash (string)`, `salt (string)`, `created_at (timestamp)`, `updated_at (timestamp)`, `is_active (boolean)`. Decide on a hashing algorithm (e.g., bcrypt).",
            "status": "done",
            "testStrategy": "Review schema definition with team, ensure all necessary fields are present and correctly typed. Verify uniqueness constraints.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop a RESTful API endpoint (`/api/register`) that allows new users to create an account, including input validation and password hashing.",
            "dependencies": [],
            "details": "Use a POST request. Validate incoming data (email format, password strength, username availability). Hash the password using the chosen algorithm before storing it. Return appropriate success/error messages.",
            "status": "done",
            "testStrategy": "Unit tests for input validation and password hashing logic. Integration tests to register a new user and verify data persistence in the database. Test edge cases like duplicate emails/usernames.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint and JWT Generation",
            "description": "Create a RESTful API endpoint (`/api/login`) that authenticates users based on credentials and issues a JSON Web Token (JWT) upon successful login.",
            "dependencies": [],
            "details": "Use a POST request. Verify provided username/email and password against stored credentials. If valid, generate a JWT containing user ID and roles, setting an appropriate expiration time. Return the JWT in the response body.",
            "status": "done",
            "testStrategy": "Unit tests for password verification and JWT generation logic. Integration tests for successful login, invalid credentials, and verifying the structure and content of the generated JWT.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement JWT Validation Middleware",
            "description": "Develop a middleware function that intercepts incoming requests, validates the JWT provided in the Authorization header, and attaches user information to the request object.",
            "dependencies": [],
            "details": "Extract the JWT from the `Authorization: Bearer <token>` header. Verify the token's signature using the secret key. Check for token expiration. Decode the payload and attach relevant user data (e.g., `userId`, `roles`) to the request object (`req.user`). Handle invalid/expired tokens by returning 401/403 errors.",
            "status": "done",
            "testStrategy": "Unit tests for token parsing, signature verification, and expiration checks. Integration tests by calling protected endpoints with valid, invalid, and expired tokens, ensuring correct access/denial.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create a Sample Protected API Endpoint",
            "description": "Develop a simple API endpoint that requires a valid JWT for access, demonstrating the functionality of the authentication module and middleware.",
            "dependencies": [],
            "details": "Create a GET endpoint (e.g., `/api/profile`) that utilizes the JWT validation middleware. If authenticated, return basic user data (e.g., username, email) retrieved from the `req.user` object. If not authenticated, the middleware should prevent access.",
            "status": "done",
            "testStrategy": "Integration tests to access the endpoint with and without a valid JWT. Verify that access is granted with a valid token and denied with an invalid or missing token. Confirm that the correct user data is returned when authenticated.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "No further expansion needed. The existing subtasks are well-defined and cover the scope of the Teacher Dashboard development."
      },
      {
        "id": 4,
        "title": "Implement Attendance Module",
        "description": "Build the attendance module for teachers to mark daily student attendance.",
        "details": "1.  Design the Attendance Module UI. 2.  Fetch and display the student list for the selected class. 3.  Implement a \"Mark All Present\" button. 4.  Allow teachers to toggle student attendance status. 5.  Integrate with the SMS Gateway API to send absence alerts to parents.",
        "testStrategy": "Test the attendance marking process, including the \"Mark All Present\" button and individual student toggling. Verify that SMS alerts are sent successfully.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project and Install Dependencies",
            "description": "Set up the basic project structure (e.g., Node.js with Express) and install all necessary packages for authentication, including `express`, `bcryptjs`, `jsonwebtoken`, and `dotenv`.",
            "dependencies": [],
            "details": "Use `npm init -y` or `yarn init -y` to start the project. Install `express` for the web server, `bcryptjs` for password hashing, `jsonwebtoken` for JWT creation and verification, and `dotenv` for environment variable management. Create a basic `server.js` or `app.js` file to start the Express application.",
            "status": "done",
            "testStrategy": "Verify that all required packages are listed in `package.json` and that the basic Express server can start without errors (e.g., by running `node server.js`).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Develop User Registration Endpoint",
            "description": "Create an API endpoint (e.g., `/api/register`) that allows new users to register by providing a username and password. The password must be securely hashed before storage.",
            "dependencies": [],
            "details": "Implement a POST route for `/api/register`. In the route handler, receive `username` and `password` from the request body. Use `bcryptjs.hash()` to hash the password with a salt. Store the user (username and hashed password) in a temporary in-memory array or a mock database. Ensure basic validation for input fields and handle duplicate usernames.",
            "status": "done",
            "testStrategy": "Use a tool like Postman or Insomnia to send POST requests to `/api/register`. Test with valid data (expect 201 Created), missing fields (expect 400 Bad Request), and an existing username (expect 409 Conflict). Verify that passwords are not stored in plain text.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop User Login and JWT Generation Endpoint",
            "description": "Create an API endpoint (e.g., `/api/login`) where existing users can authenticate with their username and password. Upon successful authentication, generate and return a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "Implement a POST route for `/api/login`. Receive `username` and `password`. Retrieve the user's stored hashed password. Use `bcryptjs.compare()` to verify the provided password against the stored hash. If credentials are valid, generate a JWT using `jsonwebtoken.sign()`, including the user's ID in the payload and signing it with a secret key loaded from environment variables. Return the JWT in the response.",
            "status": "done",
            "testStrategy": "Use Postman/Insomnia. Test with correct credentials (expect 200 OK and a JWT). Test with incorrect password or non-existent username (expect 401 Unauthorized). Verify the structure of the returned JWT.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create JWT Authentication Middleware",
            "description": "Develop a reusable middleware function that can be applied to routes to protect them. This middleware will extract and validate a JWT from the request header.",
            "dependencies": [],
            "details": "Create a middleware function (e.g., `authMiddleware.js`). It should check for an `Authorization` header in the format `Bearer <token>`. Extract the token and use `jsonwebtoken.verify()` with the secret key to validate it. If valid, decode the user information from the token and attach it to the `req` object (e.g., `req.user`). If invalid or missing, send a 401 Unauthorized or 403 Forbidden response.",
            "status": "done",
            "testStrategy": "Create a dummy protected route. Test accessing it without a token, with an invalid/expired token, and with a valid token. Verify that the middleware correctly allows access for valid tokens and denies for invalid/missing ones, returning appropriate HTTP status codes.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement a Sample Protected API Endpoint",
            "description": "Create a simple API endpoint (e.g., `/api/profile`) that demonstrates the functionality of the JWT authentication middleware by only allowing access to authenticated users.",
            "dependencies": [],
            "details": "Implement a GET route for `/api/profile`. Apply the JWT authentication middleware created in Subtask 4 to this route. In the route handler, access the user information attached by the middleware (e.g., `req.user`) and return it as part of the response to confirm successful authentication and data retrieval.",
            "status": "done",
            "testStrategy": "Use Postman/Insomnia. First, attempt to access `/api/profile` without any token (should result in 401/403). Then, log in via `/api/login` to obtain a valid JWT. Use this JWT in the `Authorization` header to access `/api/profile` (should result in 200 OK and return the user's profile data).",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "No further expansion needed. The existing subtasks are well-defined and cover the scope of the Attendance Module implementation."
      },
      {
        "id": 5,
        "title": "Develop Principal Dashboard and Reports",
        "description": "Create the Principal Dashboard and reporting features.",
        "details": "1.  Design the Principal Dashboard UI. 2.  Display real-time school-wide attendance percentage. 3.  Show a summary of academic performance (data will be populated later). 4.  Implement the functionality to post school-wide notices. 5.  Implement report generation and export (CSV/PDF) for attendance and grades.",
        "testStrategy": "Verify that the dashboard displays the correct attendance percentage and that notices can be posted. Test report generation and export functionality.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for User Management",
            "description": "Define the database tables, fields, data types, and relationships required for user accounts, roles, and authentication tokens.",
            "dependencies": [],
            "details": "Create `users` table (id, username, email, password_hash, role_id, created_at, updated_at), `roles` table (id, name), and `sessions` table (id, user_id, token, expires_at, created_at). Use PostgreSQL. Ensure proper indexing for performance.",
            "status": "done",
            "testStrategy": "Review schema with team for completeness and correctness. Verify all necessary fields are present and data types are appropriate. Run DDL scripts in a test environment.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop a RESTful API endpoint to allow new users to register with a username, email, and password.",
            "dependencies": [],
            "details": "Create `POST /api/register` endpoint. Validate input (email format, password strength). Hash password using bcrypt. Store user data in the `users` table. Handle duplicate username/email errors. Return a success message or validation errors.",
            "status": "done",
            "testStrategy": "Unit tests for password hashing and input validation. Integration tests for successful registration, registration with existing username/email, and registration with invalid input (e.g., weak password, invalid email format).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement User Login and Session Management API",
            "description": "Develop a RESTful API endpoint for user login, authenticating credentials and issuing a secure session token.",
            "dependencies": [],
            "details": "Create `POST /api/login` endpoint. Accept username/email and password. Verify password against stored hash. Generate a JWT or similar secure, expiring session token. Store token in the `sessions` table. Return the token upon successful login. Implement token invalidation on logout.",
            "status": "done",
            "testStrategy": "Unit tests for password verification and token generation. Integration tests for successful login, failed login (incorrect credentials), token expiry, and logout functionality. Test with valid and invalid tokens for protected routes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop User Profile Retrieval and Update API",
            "description": "Create API endpoints for authenticated users to retrieve their profile information and update non-sensitive details.",
            "dependencies": [],
            "details": "Implement `GET /api/profile` to return authenticated user's non-sensitive data (username, email, role). Implement `PUT /api/profile` to allow updates to fields like username or email (requiring re-authentication or password confirmation for sensitive changes). Ensure endpoints are protected by authentication middleware.",
            "status": "done",
            "testStrategy": "Integration tests for authenticated profile retrieval and update. Test unauthorized access attempts. Verify data consistency after updates. Test edge cases like updating with existing email/username.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Password Reset Workflow (Forgot Password)",
            "description": "Develop the backend logic for a 'forgot password' feature, including sending reset emails and handling password updates via a token.",
            "dependencies": [],
            "details": "Create `POST /api/forgot-password` (accepts email, generates a unique, time-limited reset token, sends email with reset link). Create `POST /api/reset-password` (accepts token and new password, validates token, updates password hash). Ensure tokens are single-use and expire.",
            "status": "done",
            "testStrategy": "Unit tests for token generation and validation. Integration tests for the entire workflow: requesting reset, using a valid token, using an expired/invalid token, and successfully resetting the password. Verify email sending mechanism.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Integrate Role-Based Access Control (RBAC) Middleware",
            "description": "Develop and integrate middleware to enforce role-based access control on various API endpoints.",
            "dependencies": [],
            "details": "Create a middleware function that checks the authenticated user's role against a list of required roles for a specific route. Apply this middleware to protected routes (e.g., admin-only endpoints). Deny access with an appropriate HTTP status code (e.g., 403 Forbidden) if the user's role is insufficient.",
            "status": "done",
            "testStrategy": "Integration tests for various user roles (e.g., admin, regular user) attempting to access protected and unprotected endpoints. Verify correct access/denial based on role. Test with unauthenticated requests.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand subtask 5.5 'Implement Report Generation and Export (Attendance & Grades)' into two distinct subtasks: one for implementing CSV export functionality (e.g., for attendance) and another for implementing PDF export functionality (e.g., for grades), each focusing on data retrieval, formatting, and client-side library integration. Consider adding a subtask for optimizing data retrieval for potentially large reports."
      },
      {
        "id": 6,
        "title": "Implement Admin Setup Module",
        "description": "Develop the Admin Setup Module for managing core school data.",
        "details": "1.  Design the Admin Setup Module UI. 2.  Implement the bulk import of Student and Teacher data from a CSV template. 3.  Implement the Timetable management interface. 4.  Implement the creation and management of staff login credentials.",
        "testStrategy": "Test the CSV import functionality. Verify that new teacher accounts can be created and managed.",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Database Schema",
            "description": "Define the database table structure for storing user information, including fields for username, email, password hash, and roles.",
            "dependencies": [],
            "details": "Create a `users` table with columns: `id` (PK, auto-increment), `username` (unique, string), `email` (unique, string), `password_hash` (string), `created_at` (timestamp), `updated_at` (timestamp). Consider indexing `username` and `email` for performance.",
            "status": "done",
            "testStrategy": "Verify table creation and column definitions using a database client (e.g., psql, MySQL Workbench). Insert dummy data to ensure schema integrity.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to register by providing a username, email, and password. The password should be hashed before storage.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Validate input for uniqueness of username/email and password strength. Use a strong hashing algorithm (e.g., bcrypt) for passwords. Store the hashed password in the database.",
            "status": "done",
            "testStrategy": "Use Postman/cURL to send valid registration requests, invalid requests (e.g., missing fields, duplicate username/email, weak password). Verify user creation in the database and appropriate error responses.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop JWT Generation and Verification Utility",
            "description": "Create a set of utility functions for generating, signing, and verifying JSON Web Tokens.",
            "dependencies": [],
            "details": "Implement functions like `generateToken(payload, secret, expiresIn)` and `verifyToken(token, secret)`. The payload should include user ID and roles. Define a secure secret key and an appropriate expiration time for tokens.",
            "status": "done",
            "testStrategy": "Write unit tests for each utility function: ensure tokens are generated correctly with the given payload, verify valid tokens, and confirm that invalid or expired tokens are rejected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint (`/api/login`) that authenticates users based on their username/email and password, returning a JWT upon successful login.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Retrieve user by username/email. Compare provided password with stored hash. If credentials are valid, generate a JWT using the utility function and return it in the response body.",
            "status": "done",
            "testStrategy": "Use Postman/cURL to send valid login requests (verify JWT generation) and invalid requests (e.g., wrong password, non-existent user). Check for correct JWT structure and appropriate error messages.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement JWT Authentication Middleware",
            "description": "Create a middleware function that protects API routes by verifying the presence and validity of a JWT in the request header.",
            "dependencies": [],
            "details": "The middleware should extract the token from the `Authorization: Bearer <token>` header. Use the JWT verification utility. If valid, decode the token and attach the user payload (e.g., user ID, roles) to the request object. If invalid or missing, return a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "Apply the middleware to a dummy protected route. Test access with a valid JWT, an invalid JWT, an expired JWT, and no JWT. Verify that authenticated requests proceed and unauthenticated ones are rejected with the correct status code.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create a Protected API Route Example",
            "description": "Implement a simple API endpoint that requires authentication using the developed JWT middleware to demonstrate its functionality.",
            "dependencies": [],
            "details": "Create a GET endpoint (e.g., `/api/profile`) that returns basic user information (e.g., username, email) retrieved from the request object (populated by the middleware). This route should only be accessible to authenticated users.",
            "status": "done",
            "testStrategy": "Perform an authenticated request to `/api/profile` using a JWT obtained from the login endpoint. Verify that user data is returned. Perform an unauthenticated request to the same endpoint and confirm it returns a 401 Unauthorized error.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Revise subtask 6.1 to reflect the HTML/JS/Alpine.js tech stack (e.g., `src/pages/admin/setup.html`). Expand subtask 6.2 'Implement CSV Bulk Import Frontend' and 6.3 'Develop Backend API for Bulk Data Import' into more granular steps, separating frontend parsing/preview from backend validation/database insertion. Also, ensure subtask 6.5 'Implement Staff Login Credentials Management' explicitly considers the need for secure backend functions (e.g., Supabase Edge Functions) for sensitive Supabase Auth Admin API calls."
      },
      {
        "id": 7,
        "title": "Design and Implement Data Model in Supabase",
        "description": "Define and implement the database schema in Supabase.",
        "details": "1.  Design the database schema for Students, Teachers, Classes, Timetables, AttendanceRecords, and Notices. 2.  Create tables in Supabase based on the data model. 3.  Implement relationships between tables.",
        "testStrategy": "Verify that the database schema is correctly implemented and that the relationships between tables are established.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project and Install Dependencies",
            "description": "Set up a new Node.js project and install all required packages for building a user authentication system.",
            "dependencies": [],
            "details": "Use `npm init -y` to create `package.json`. Install core dependencies: `express`, `bcryptjs` (for password hashing), `jsonwebtoken` (for JWTs), `dotenv` (for environment variables), and `mongoose` (for database interaction). Configure basic server structure and database connection.",
            "status": "done",
            "testStrategy": "Verify `package.json` contains all listed dependencies. Ensure the server starts without errors and connects to the database successfully.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to sign up, securely hashing their passwords before saving them to the database.",
            "dependencies": [],
            "details": "Define a Mongoose User schema with fields like `username`, `email`, and `password`. Implement a POST `/api/register` route. Before saving, hash the provided password using `bcryptjs.hash()`. Handle potential errors such as duplicate usernames/emails and validation failures. Return a success message or the newly created user (excluding password).",
            "status": "done",
            "testStrategy": "Use Postman or cURL to send POST requests to `/api/register` with valid user data. Verify that a new user record is created in the database with a hashed password. Test with invalid data (e.g., missing fields, existing username) and assert appropriate error responses.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement User Login Endpoint and JWT Generation",
            "description": "Create an API endpoint (`/api/login`) for user authentication, verifying credentials and issuing a JSON Web Token (JWT) upon successful login.",
            "dependencies": [],
            "details": "Implement a POST `/api/login` route. Find the user by their provided username/email. Compare the provided password with the stored hashed password using `bcryptjs.compare()`. If credentials are valid, generate a JWT using `jsonwebtoken.sign()` including the user's ID and a secret key. Return the generated JWT to the client.",
            "status": "done",
            "testStrategy": "Use Postman or cURL to send POST requests to `/api/login` with correct and incorrect credentials. Verify that a valid JWT is returned for successful logins and appropriate error messages (e.g., 'Invalid credentials') for failed attempts. Ensure the JWT payload contains the user ID.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop JWT Authentication Middleware",
            "description": "Create a middleware function that verifies the presence and validity of a JWT in the request header for protecting API routes.",
            "dependencies": [],
            "details": "Create a middleware function (e.g., `authMiddleware.js`). This middleware should extract the token from the `Authorization` header (e.g., 'Bearer TOKEN'). Use `jsonwebtoken.verify()` to validate the token against the secret key. If valid, decode the token, attach the user's ID (from the token payload) to the `req` object (e.g., `req.user = { id: decoded.id }`), and call `next()`. Handle cases where the token is missing, invalid, or expired by sending appropriate HTTP error responses (e.g., 401 Unauthorized, 403 Forbidden).",
            "status": "done",
            "testStrategy": "Test the middleware by attempting to access a protected route (to be created in subtask 5) with no token, an invalid token, and a valid token. Ensure correct access is granted only with a valid token and appropriate error responses are returned otherwise.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create a Sample Protected Route",
            "description": "Implement a simple API endpoint that can only be accessed by authenticated users, demonstrating the functionality of the JWT authentication middleware.",
            "dependencies": [],
            "details": "Create a GET `/api/profile` or `/api/dashboard` route. Apply the `authMiddleware` created in subtask 4 to this route. The route handler should access `req.user.id` (populated by the middleware) to demonstrate that the user's identity is available after authentication. Return some user-specific data or a simple success message.",
            "status": "done",
            "testStrategy": "Use Postman or cURL. Attempt to access `/api/profile` without a token (should result in 401/403). Attempt with an invalid token (should result in 401/403). Obtain a valid token from `/api/login` and use it to access `/api/profile` (should succeed and return the expected data, confirming `req.user` is populated).",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "No further expansion needed. The existing subtasks are well-defined and cover the scope of data model design and implementation."
      },
      {
        "id": 8,
        "title": "Integrate SMS Gateway API",
        "description": "Integrate the SMS Gateway API for sending absence alerts.",
        "details": "1.  Choose an SMS Gateway API provider. 2.  Implement the API integration to send SMS messages to parents when a student is marked absent. 3.  Test the SMS sending functionality.",
        "testStrategy": "Verify that SMS messages are sent successfully to the parents of absent students.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for Users",
            "description": "Define the database table structure for storing user information, including fields for username, email, password hash, salt, and roles.",
            "dependencies": [],
            "details": "Create a `users` table with columns: `id (PK, UUID)`, `username (VARCHAR UNIQUE)`, `email (VARCHAR UNIQUE)`, `password_hash (VARCHAR)`, `password_salt (VARCHAR)`, `created_at (TIMESTAMP)`, `updated_at (TIMESTAMP)`, `is_active (BOOLEAN DEFAULT TRUE)`. Consider indexing `username` and `email` for performance.",
            "status": "done",
            "testStrategy": "Review schema definition with the team lead and database administrator. Ensure all required fields are present, data types are appropriate, and constraints (e.g., UNIQUE) are correctly applied.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to sign up by providing a username, email, and password. This endpoint should handle input validation, password hashing, and storing user data in the database.",
            "dependencies": [],
            "details": "Use `POST /api/register`. Implement robust input validation for username (min/max length, allowed characters), email (format), and password (min length, complexity requirements). Use a strong, industry-standard hashing algorithm (e.g., bcrypt) for password hashing, generating a unique salt for each user. Store the hashed password and salt in the database. Return a success message or appropriate error codes (e.g., 400 for bad input, 409 for existing user).",
            "status": "done",
            "testStrategy": "Develop unit tests for input validation logic, password hashing, and database insertion. Create integration tests for the endpoint, covering valid registrations, invalid inputs (e.g., weak password, invalid email), and attempts to register with an already existing username/email. Verify database entries for newly registered users.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop JWT Token Generation and Validation Utilities",
            "description": "Create utility functions for generating JSON Web Tokens (JWTs) upon successful login and for validating incoming JWTs for protected routes.",
            "dependencies": [],
            "details": "Utilize a standard JWT library (e.g., `jsonwebtoken` in Node.js, `PyJWT` in Python). Implement `generateToken(payload, secret, options)` to create signed tokens with user-specific data (e.g., user ID, roles, expiration time). Implement `verifyToken(token, secret)` to decode and validate tokens, checking signature and expiration. Define the JWT secret key as an environment variable.",
            "status": "done",
            "testStrategy": "Write unit tests for token generation (verify payload correctness, expiration time). Test token validation with valid tokens, expired tokens, tokens with invalid signatures, and malformed tokens. Ensure appropriate errors or exceptions are raised for invalid tokens.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint (`/api/login`) that authenticates users based on their username/email and password, returning an authentication token upon successful login.",
            "dependencies": [],
            "details": "Use `POST /api/login`. Accept username/email and password. Retrieve the user's record from the database. Compare the provided password with the stored hashed password using the stored salt. If credentials are valid, use the utility from subtask 3 to generate a JWT token. Return the JWT token in the response body (e.g., as a bearer token). Handle invalid credentials with a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "Develop unit tests for password verification logic. Create integration tests for the endpoint, covering successful logins with correct credentials, failed logins with incorrect passwords, and failed logins with non-existent users. Verify that a valid JWT is returned on success and appropriate error codes are returned on failure.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Authentication Middleware for Protected Routes",
            "description": "Implement middleware that uses the JWT validation utility to protect specific API routes, ensuring only authenticated users with valid tokens can access them.",
            "dependencies": [],
            "details": "Create an `authMiddleware` function. This middleware should extract the JWT from the `Authorization` header (e.g., 'Bearer <token>'). Use the `verifyToken` utility from subtask 3 to validate the token. If valid, decode the token's payload and attach relevant user information (e.g., `req.user = decoded_payload`) to the request object for subsequent route handlers. If the token is missing, invalid, or expired, return a 401 Unauthorized or 403 Forbidden error. Apply this middleware to at least one sample protected route (e.g., `/api/profile`).",
            "status": "done",
            "testStrategy": "Create integration tests for a protected route: attempt access with a valid token, an expired token, an invalid token, and no token. Verify that access is granted only with a valid token and that appropriate HTTP status codes (e.g., 200, 401, 403) are returned in other scenarios. Ensure user information is correctly attached to the request object when authenticated.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "No further expansion needed. The existing subtasks are well-defined and cover the scope of SMS Gateway integration.",
        "updatedAt": "2025-10-23T06:15:34.957Z"
      },
      {
        "id": 9,
        "title": "Implement Offline Support",
        "description": "Implement offline support for the application.",
        "details": "1.  Implement caching for the last loaded timetable and notices. 2.  Allow the attendance module to work offline and auto-sync when connectivity is restored.",
        "testStrategy": "Test the application's behavior when offline. Verify that the timetable and notices are displayed correctly and that attendance data is saved and synced when connectivity is restored.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for User Management",
            "description": "Define the database tables and fields required to store user information, including authentication credentials and profile data.",
            "dependencies": [],
            "details": "Create `users` table with fields: `id` (PK), `username` (unique), `email` (unique), `password_hash`, `salt`, `created_at`, `updated_at`, `is_active`. Consider indexing `username` and `email`.",
            "status": "done",
            "testStrategy": "Review DDL for correctness and completeness. Execute DDL on a test database and verify table and column creation.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop an API endpoint that allows new users to register by providing a username, email, and password, storing their hashed credentials securely.",
            "dependencies": [],
            "details": "Endpoint: `POST /api/auth/register`. Validate input (email format, password strength). Hash password using bcrypt with a generated salt. Store user data in the `users` table. Return a success message or appropriate error.",
            "status": "done",
            "testStrategy": "Use Postman/cURL to test with valid and invalid inputs (missing fields, duplicate username/email, weak password). Verify user creation in the database and appropriate HTTP status codes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint for users to authenticate with their credentials and receive a JSON Web Token (JWT) upon successful login.",
            "dependencies": [],
            "details": "Endpoint: `POST /api/auth/login`. Validate input (username/email, password). Retrieve user from DB. Compare provided password with stored hash using bcrypt. If valid, generate a JWT containing user ID and roles. Return the JWT.",
            "status": "done",
            "testStrategy": "Test with valid credentials, invalid password, non-existent user. Verify JWT structure and content for successful logins. Check for appropriate error responses (e.g., 401 Unauthorized).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop JWT Generation and Validation Utilities",
            "description": "Create helper functions or a service for generating, signing, and verifying JSON Web Tokens.",
            "dependencies": [],
            "details": "Implement functions: `generateToken(payload, secret, expiresIn)` and `verifyToken(token, secret)`. Use a robust JWT library. Ensure the secret key is loaded from environment variables and is sufficiently complex.",
            "status": "done",
            "testStrategy": "Unit tests for `generateToken` with various payloads. Unit tests for `verifyToken` with valid, invalid, expired, and tampered tokens. Ensure correct error handling for verification failures.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement JWT Authentication Middleware",
            "description": "Create a middleware function that protects API routes by validating the JWT provided in the request header.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization: Bearer <token>` header. Use the `verifyToken` utility. If valid, decode the payload and attach user information (e.g., `req.user`) to the request object. If invalid or missing, return a 401 Unauthorized response.",
            "status": "done",
            "testStrategy": "Create a dummy protected route. Test access with a valid JWT, an expired JWT, an invalid JWT, and no JWT. Verify that valid tokens grant access and invalid/missing tokens result in 401.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement Protected User Profile Endpoint",
            "description": "Develop a simple API endpoint that returns the authenticated user's profile information, accessible only after successful JWT authentication.",
            "dependencies": [],
            "details": "Endpoint: `GET /api/user/profile`. Apply the JWT authentication middleware to this route. Retrieve user details from the `req.user` object populated by the middleware (e.g., username, email). Return these details.",
            "status": "done",
            "testStrategy": "Access the endpoint using a valid JWT obtained from the login endpoint. Access without a JWT. Access with an invalid/expired JWT. Verify that the correct user data is returned for authenticated requests and 401 for unauthenticated ones.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Expand subtask 9.5 'Implement Attendance Auto-Sync Mechanism' into two distinct subtasks: one focusing on the core logic of sending queued attendance data to Supabase upon network restoration, and another dedicated to implementing robust error handling, retry strategies, and providing clear UI feedback to the user regarding sync status and potential failures."
      },
      {
        "id": 10,
        "title": "Testing, Deployment, and Documentation",
        "description": "Comprehensive testing, deployment, and documentation.",
        "details": "1.  Conduct thorough testing of all features. 2.  Deploy the frontend to Vercel/Netlify. 3.  Set up a CI/CD pipeline for automated deployments. 4.  Create user documentation and training materials.",
        "testStrategy": "Perform end-to-end testing of all features. Verify that the application is deployed correctly and that the documentation is accurate.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for Users and Sessions",
            "description": "Define the database tables, columns, data types, and relationships for storing user accounts and active session tokens.",
            "dependencies": [],
            "details": "Create a 'users' table (id, username, email, password_hash, created_at, updated_at) and a 'sessions' table (id, user_id, token, expires_at, created_at). Ensure appropriate indexing for performance on common lookup fields (username, email, session token).",
            "status": "done",
            "testStrategy": "Review schema with team members for correctness, normalization, and potential performance bottlenecks. Verify all necessary fields are present and data types are suitable.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop a RESTful API endpoint to handle new user registrations, including input validation and secure password hashing.",
            "dependencies": [],
            "details": "Create a POST /api/register endpoint. It should accept username, email, and password. Validate email format, username uniqueness, and password strength. Hash the password using a strong, modern algorithm (e.g., bcrypt) before storing it in the 'users' table. Return appropriate success/error responses.",
            "status": "done",
            "testStrategy": "Unit tests for input validation (valid/invalid email, short password, existing username). Integration tests for the endpoint with successful registration and various failure scenarios (e.g., duplicate email, weak password).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint",
            "description": "Develop a RESTful API endpoint for user authentication, verifying credentials and issuing a secure session token.",
            "dependencies": [],
            "details": "Create a POST /api/login endpoint. It should accept username/email and password. Verify the provided password against the stored hash. If credentials are valid, generate a unique, expiring session token and store it in the 'sessions' table linked to the user_id. Return the session token to the client.",
            "status": "done",
            "testStrategy": "Unit tests for password comparison logic and token generation. Integration tests for the endpoint with correct credentials, incorrect password, non-existent user, and ensuring a valid token is returned on success.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Develop Session Authentication Middleware",
            "description": "Create a middleware component to protect API routes by validating incoming session tokens and attaching user context to requests.",
            "dependencies": [],
            "details": "The middleware should extract the session token from the request header (e.g., 'Authorization: Bearer <token>'). It must then look up the token in the 'sessions' table, verify its validity (not expired), and retrieve the associated user data. If valid, attach the user object to the request (e.g., req.user) and call next(). If invalid or missing, return a 401 Unauthorized response.",
            "status": "done",
            "testStrategy": "Unit tests for token parsing, expiration checks, and database lookup. Integration tests by applying the middleware to a dummy protected route, testing with valid, expired, invalid, and missing tokens.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement User Profile Retrieval API Endpoint",
            "description": "Create a protected API endpoint that allows an authenticated user to retrieve their own profile information.",
            "dependencies": [],
            "details": "Create a GET /api/profile endpoint. This endpoint must be protected by the session authentication middleware (Subtask 4). It should use the user information attached to the request by the middleware to fetch and return non-sensitive profile data (e.g., username, email, created_at) from the 'users' table.",
            "status": "done",
            "testStrategy": "Integration tests to ensure only authenticated users can access this endpoint. Test with valid tokens to verify correct user data is returned, and with invalid/missing tokens to confirm 401 responses.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement User Logout API Endpoint",
            "description": "Develop a protected API endpoint that invalidates the current user's active session token.",
            "dependencies": [],
            "details": "Create a POST /api/logout endpoint. This endpoint must be protected by the session authentication middleware. It should use the session token from the request (or the user_id from the authenticated request context) to mark the corresponding session in the 'sessions' table as expired or delete it entirely. Return a success message.",
            "status": "done",
            "testStrategy": "Integration tests to ensure that after a successful logout, subsequent requests using the invalidated token result in a 401 Unauthorized response. Test edge cases like attempting to log out an already expired or non-existent session.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Revise subtask 10.1 'Implement Comprehensive Unit and Integration Tests' to specify appropriate testing frameworks for HTML, JavaScript, and Alpine.js (e.g., Jest for JS logic, and potentially a browser-based testing utility for Alpine.js component interactions). Consider splitting this into two subtasks: one for setting up the chosen testing framework(s) and another for writing the actual tests. Also, ensure the CI/CD pipeline (subtask 10.4) correctly integrates these new testing setups."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-23T06:15:34.959Z",
      "taskCount": 10,
      "completedCount": 8,
      "tags": [
        "master"
      ],
      "created": "2025-10-23T06:51:11.916Z",
      "description": "Tasks for master context",
      "updated": "2025-10-23T06:55:07.541Z"
    }
  },
  "feature-task-4-attendance-sms": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Development Environment and Project Structure",
        "description": "Initialize the project with the specified technology stack and establish the basic file structure.",
        "details": "1.  Set up a Supabase project. 2.  Initialize a new project using HTML, CSS, JavaScript, Tailwind CSS (via CDN), and Alpine.js. 3.  Create the basic file structure (e.g., `index.html`, `styles.css`, `script.js`, and folders for components, pages, etc.). 4.  Configure Vercel/Netlify for frontend deployment.",
        "testStrategy": "Verify that the basic project structure is created and that the frontend can be deployed to Vercel/Netlify.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Database Schema",
            "description": "Define the database table structure for storing user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Include fields for `id`, `username` (unique), `email` (unique), `password_hash`, `salt`, `created_at`, `updated_at`, `is_active`. Consider indexing `username` and `email` for performance. Use appropriate data types for each field.",
            "status": "done",
            "testStrategy": "Review schema with team for completeness and correctness. Verify data types, constraints (e.g., unique, not null), and indexing. Create migration scripts and test their execution."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create a backend API endpoint to handle new user registrations, including data validation and secure password hashing.",
            "dependencies": [],
            "details": "Endpoint should be `POST /api/register`. Validate input fields (`username`, `email`, `password`) for format, length, and uniqueness. Hash password using a strong algorithm (e.g., bcrypt) with a generated salt. Store user data in the database. Return appropriate success/error responses.",
            "status": "done",
            "testStrategy": "Unit tests for input validation, password hashing, and database interaction. Integration tests for successful registration, duplicate username/email errors, and invalid input errors. Use tools like Postman or curl for manual API testing."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint",
            "description": "Create a backend API endpoint to authenticate users based on their username/email and password, issuing a JWT token upon success.",
            "dependencies": [],
            "details": "Endpoint should be `POST /api/login`. Retrieve user by username or email. Compare provided password with the stored hash using the correct salt. If credentials are valid, generate a JSON Web Token (JWT) containing user ID and roles, and return it. Handle invalid credentials gracefully.",
            "status": "done",
            "testStrategy": "Unit tests for password comparison logic and JWT generation. Integration tests for successful login, incorrect password, non-existent user, and token validity. Test token expiration and refresh mechanisms if implemented."
          },
          {
            "id": 4,
            "title": "Develop Frontend Registration Form",
            "description": "Create a user interface component for new users to register an account, interacting with the registration API.",
            "dependencies": [],
            "details": "Design an HTML form with fields for username, email, password, and confirm password. Implement client-side validation for input format and password matching. On submission, send data to the `/api/register` endpoint. Display success messages or API error feedback to the user.",
            "status": "done",
            "testStrategy": "Manual testing for form submission, client-side validation, and display of API responses (success/error). Automated UI tests (e.g., Cypress, Playwright) to simulate user registration flow and verify UI updates."
          },
          {
            "id": 5,
            "title": "Develop Frontend Login Form",
            "description": "Create a user interface component for existing users to log in, interacting with the login API and handling the JWT token.",
            "dependencies": [],
            "details": "Design an HTML form with fields for username/email and password. Implement client-side validation. On submission, send data to the `/api/login` endpoint. Upon successful login, store the received JWT token (e.g., in local storage) and redirect the user to a protected area of the application.",
            "status": "done",
            "testStrategy": "Manual testing for form submission, client-side validation, and correct handling of API responses (success/failure). Verify that the JWT token is stored correctly and that the user is redirected. Automated UI tests for login flow and token persistence."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement User Authentication",
        "description": "Develop the user authentication system for teachers and the principal.",
        "details": "1.  Design and implement the login page with separate portals/redirects for Teacher and Principal. 2.  Integrate Supabase authentication for user login with unique ID and password. 3.  Implement password reset functionality (handled by Principal for MVP). 4.  Implement role-based access control (Teacher and Principal).",
        "testStrategy": "Test login functionality for both Teacher and Principal roles. Verify correct redirection to respective dashboards. Test password reset functionality.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Database Schema",
            "description": "Define the database table structure for storing user information, including fields for username, email, password hash, and roles.",
            "dependencies": [],
            "details": "Use SQL DDL to create a `users` table. Include columns for `id` (PK), `username` (unique), `email` (unique), `password_hash`, `created_at`, `updated_at`. Consider indexing `username` and `email` for performance.",
            "status": "done",
            "testStrategy": "Verify table creation and column definitions using a database client. Ensure unique constraints are enforced."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to register by providing a username, email, and password. The password should be hashed before storage.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Validate input fields (e.g., email format, password strength, uniqueness of username/email). Hash passwords using a strong algorithm like bcrypt. Store user data in the database.",
            "status": "done",
            "testStrategy": "Use Postman/cURL to send valid and invalid registration requests. Check database for new user entry and correct password hash. Test edge cases like existing username/email."
          },
          {
            "id": 3,
            "title": "Develop JWT Generation and Verification Utility",
            "description": "Create a set of utility functions for generating, signing, and verifying JSON Web Tokens.",
            "dependencies": [],
            "details": "Use a library like `jsonwebtoken`. Define a secure secret key (e.g., from environment variables). Implement functions for `generateToken(payload, expiresIn)` and `verifyToken(token)`. The payload should include user ID and roles.",
            "status": "done",
            "testStrategy": "Unit tests for token generation with various payloads and expiration times. Unit tests for token verification with valid, invalid, and expired tokens. Ensure correct error handling for invalid tokens."
          },
          {
            "id": 4,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint (`/api/login`) that authenticates users based on their username/email and password, returning a JWT upon successful login.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Retrieve user from database by username/email. Compare provided password with stored hash. If valid, use the JWT utility to generate and return a token. Handle invalid credentials gracefully.",
            "status": "done",
            "testStrategy": "Use Postman/cURL to send valid and invalid login requests. Verify JWT generation and structure for valid logins. Test with incorrect passwords and non-existent users."
          },
          {
            "id": 5,
            "title": "Implement JWT Authentication Middleware",
            "description": "Create a middleware function that protects API routes by verifying the presence and validity of a JWT in the request header.",
            "dependencies": [],
            "details": "Extract token from `Authorization: Bearer <token>` header. Use the `verifyToken` utility. If valid, attach user information (e.g., user ID, roles) to the request object. If invalid or missing, return a 401 Unauthorized response.",
            "status": "done",
            "testStrategy": "Create a dummy protected route. Test access with valid, invalid, expired, and missing JWTs. Verify that user information is correctly attached to the request for valid tokens."
          },
          {
            "id": 6,
            "title": "Implement Protected User Profile Endpoint",
            "description": "Create a protected API endpoint (`/api/profile`) that returns the authenticated user's profile information.",
            "dependencies": [],
            "details": "Apply the JWT authentication middleware to this route. The endpoint should be a GET request. Fetch user details from the database using the user ID obtained from the verified token (attached by the middleware). Return relevant profile data.",
            "status": "done",
            "testStrategy": "Test access with a valid JWT (obtained from login). Test access without a JWT and with an invalid/expired JWT. Verify that the correct user data is returned for authenticated requests and that unauthorized requests are rejected."
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop Teacher Dashboard",
        "description": "Create the teacher dashboard to display relevant information and provide quick access to core features.",
        "details": "1.  Design the Teacher Dashboard UI based on the provided mockup. 2.  Fetch and display the teacher's current/next class from the timetable (data will be populated later). 3.  Implement a button to mark attendance. 4.  Display a list of recent unread notices. 5.  Include quick access buttons to other modules (Grades, Timetable).",
        "testStrategy": "Verify that the dashboard loads correctly, displays the correct schedule, and that the quick access buttons are functional.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for User Authentication",
            "description": "Define the database table structure required for storing user accounts, including fields for username, email, password hash, and roles.",
            "dependencies": [],
            "details": "Consider fields like `id (PK)`, `username (unique, string)`, `email (unique, string)`, `password_hash (string)`, `salt (string)`, `created_at (timestamp)`, `updated_at (timestamp)`, `is_active (boolean)`. Decide on a hashing algorithm (e.g., bcrypt).",
            "status": "pending",
            "testStrategy": "Review schema definition with team, ensure all necessary fields are present and correctly typed. Verify uniqueness constraints."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop a RESTful API endpoint (`/api/register`) that allows new users to create an account, including input validation and password hashing.",
            "dependencies": [],
            "details": "Use a POST request. Validate incoming data (email format, password strength, username availability). Hash the password using the chosen algorithm before storing it. Return appropriate success/error messages.",
            "status": "pending",
            "testStrategy": "Unit tests for input validation and password hashing logic. Integration tests to register a new user and verify data persistence in the database. Test edge cases like duplicate emails/usernames."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint and JWT Generation",
            "description": "Create a RESTful API endpoint (`/api/login`) that authenticates users based on credentials and issues a JSON Web Token (JWT) upon successful login.",
            "dependencies": [],
            "details": "Use a POST request. Verify provided username/email and password against stored credentials. If valid, generate a JWT containing user ID and roles, setting an appropriate expiration time. Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Unit tests for password verification and JWT generation logic. Integration tests for successful login, invalid credentials, and verifying the structure and content of the generated JWT."
          },
          {
            "id": 4,
            "title": "Implement JWT Validation Middleware",
            "description": "Develop a middleware function that intercepts incoming requests, validates the JWT provided in the Authorization header, and attaches user information to the request object.",
            "dependencies": [],
            "details": "Extract the JWT from the `Authorization: Bearer <token>` header. Verify the token's signature using the secret key. Check for token expiration. Decode the payload and attach relevant user data (e.g., `userId`, `roles`) to the request object (`req.user`). Handle invalid/expired tokens by returning 401/403 errors.",
            "status": "pending",
            "testStrategy": "Unit tests for token parsing, signature verification, and expiration checks. Integration tests by calling protected endpoints with valid, invalid, and expired tokens, ensuring correct access/denial."
          },
          {
            "id": 5,
            "title": "Create a Sample Protected API Endpoint",
            "description": "Develop a simple API endpoint that requires a valid JWT for access, demonstrating the functionality of the authentication module and middleware.",
            "dependencies": [],
            "details": "Create a GET endpoint (e.g., `/api/profile`) that utilizes the JWT validation middleware. If authenticated, return basic user data (e.g., username, email) retrieved from the `req.user` object. If not authenticated, the middleware should prevent access.",
            "status": "pending",
            "testStrategy": "Integration tests to access the endpoint with and without a valid JWT. Verify that access is granted with a valid token and denied with an invalid or missing token. Confirm that the correct user data is returned when authenticated."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Attendance Module",
        "description": "Build the attendance module for teachers to mark daily student attendance.",
        "details": "1.  Design the Attendance Module UI. 2.  Fetch and display the student list for the selected class. 3.  Implement a \"Mark All Present\" button. 4.  Allow teachers to toggle student attendance status. 5.  Integrate with the SMS Gateway API to send absence alerts to parents.",
        "testStrategy": "Test the attendance marking process, including the \"Mark All Present\" button and individual student toggling. Verify that SMS alerts are sent successfully.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Attendance Module UI and Class Selector",
            "description": "Develop the basic UI for the attendance module, including a class selection dropdown/component. This module should be accessible from the Teacher Dashboard.",
            "dependencies": [],
            "details": "Create a new React component (e.g., `AttendanceModule.jsx`) within `src/components` or `src/pages/teacher`. Implement a dropdown or similar UI element to allow teachers to select a class. Fetch the list of available classes from Supabase using existing `src/services/apiClasses.js` functions and populate the class selector. Integrate this new component into `src/pages/TeacherDashboardPage.jsx`.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Fetch and Display Student List for Selected Class",
            "description": "Implement the logic to fetch and display the list of students for the selected class within the Attendance Module UI.",
            "dependencies": [
              "4.1"
            ],
            "details": "Extend `src/services/apiStudents.js` or create `src/services/apiAttendance.js` with a function to fetch students by `class_id`. When a class is selected in the UI (from subtask 4.1), call this function to retrieve the student list. Display the student names in a table or list format within the `AttendanceModule` component, initially marking all students as 'Present' by default in the UI state.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Attendance Marking Functionality (Toggle & Mark All)",
            "description": "Add interactive elements to mark individual student attendance and a 'Mark All Present' button.",
            "dependencies": [
              "4.2"
            ],
            "details": "For each student displayed in the list (from subtask 4.2), add a toggle component (e.g., checkbox, switch) to allow teachers to change their attendance status between 'Present' and 'Absent'. Implement a 'Mark All Present' button that, when clicked, updates the local state to set all students' attendance status to 'Present'. Manage the attendance status for each student locally within the component's state.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Persist Attendance Data to Supabase",
            "description": "Develop the backend integration to save the marked attendance data to the Supabase database.",
            "dependencies": [
              "4.3"
            ],
            "details": "Define and create a new `attendance` table in Supabase with appropriate columns (e.g., `id`, `student_id`, `class_id`, `date`, `status` (e.g., 'present', 'absent'), `marked_by_teacher_id`, `created_at`). Implement a function in `src/services/apiAttendance.js` to handle inserting or updating attendance records for all students of a selected class for a specific date. This function should be triggered by a 'Submit Attendance' button in the UI, using the teacher's ID from the authentication context.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate SMS Gateway for Absence Alerts",
            "description": "Implement the functionality to send SMS alerts to parents of absent students via an SMS Gateway API.",
            "dependencies": [
              "4.4"
            ],
            "details": "After attendance data is successfully persisted (subtask 4.4), identify all students marked 'Absent'. For each absent student, fetch their parent's phone number from the `students` table (which should contain a `parent_phone_number` column). Create a new function in `src/services/apiSMS.js` (or extend `apiAttendance.js`) that takes a list of absent students and their parent phone numbers, then makes an API call to an external SMS gateway (e.g., Twilio, or a Supabase Edge Function acting as a proxy) to send a predefined absence alert message to the respective parents.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Develop Principal Dashboard and Reports",
        "description": "Create the Principal Dashboard and reporting features.",
        "details": "1.  Design the Principal Dashboard UI. 2.  Display real-time school-wide attendance percentage. 3.  Show a summary of academic performance (data will be populated later). 4.  Implement the functionality to post school-wide notices. 5.  Implement report generation and export (CSV/PDF) for attendance and grades.",
        "testStrategy": "Verify that the dashboard displays the correct attendance percentage and that notices can be posted. Test report generation and export functionality.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for User Management",
            "description": "Define the database tables, fields, data types, and relationships required for user accounts, roles, and authentication tokens.",
            "dependencies": [],
            "details": "Create `users` table (id, username, email, password_hash, role_id, created_at, updated_at), `roles` table (id, name), and `sessions` table (id, user_id, token, expires_at, created_at). Use PostgreSQL. Ensure proper indexing for performance.",
            "status": "pending",
            "testStrategy": "Review schema with team for completeness and correctness. Verify all necessary fields are present and data types are appropriate. Run DDL scripts in a test environment."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop a RESTful API endpoint to allow new users to register with a username, email, and password.",
            "dependencies": [],
            "details": "Create `POST /api/register` endpoint. Validate input (email format, password strength). Hash password using bcrypt. Store user data in the `users` table. Handle duplicate username/email errors. Return a success message or validation errors.",
            "status": "pending",
            "testStrategy": "Unit tests for password hashing and input validation. Integration tests for successful registration, registration with existing username/email, and registration with invalid input (e.g., weak password, invalid email format)."
          },
          {
            "id": 3,
            "title": "Implement User Login and Session Management API",
            "description": "Develop a RESTful API endpoint for user login, authenticating credentials and issuing a secure session token.",
            "dependencies": [],
            "details": "Create `POST /api/login` endpoint. Accept username/email and password. Verify password against stored hash. Generate a JWT or similar secure, expiring session token. Store token in the `sessions` table. Return the token upon successful login. Implement token invalidation on logout.",
            "status": "pending",
            "testStrategy": "Unit tests for password verification and token generation. Integration tests for successful login, failed login (incorrect credentials), token expiry, and logout functionality. Test with valid and invalid tokens for protected routes."
          },
          {
            "id": 4,
            "title": "Develop User Profile Retrieval and Update API",
            "description": "Create API endpoints for authenticated users to retrieve their profile information and update non-sensitive details.",
            "dependencies": [],
            "details": "Implement `GET /api/profile` to return authenticated user's non-sensitive data (username, email, role). Implement `PUT /api/profile` to allow updates to fields like username or email (requiring re-authentication or password confirmation for sensitive changes). Ensure endpoints are protected by authentication middleware.",
            "status": "pending",
            "testStrategy": "Integration tests for authenticated profile retrieval and update. Test unauthorized access attempts. Verify data consistency after updates. Test edge cases like updating with existing email/username."
          },
          {
            "id": 5,
            "title": "Implement Password Reset Workflow (Forgot Password)",
            "description": "Develop the backend logic for a 'forgot password' feature, including sending reset emails and handling password updates via a token.",
            "dependencies": [],
            "details": "Create `POST /api/forgot-password` (accepts email, generates a unique, time-limited reset token, sends email with reset link). Create `POST /api/reset-password` (accepts token and new password, validates token, updates password hash). Ensure tokens are single-use and expire.",
            "status": "pending",
            "testStrategy": "Unit tests for token generation and validation. Integration tests for the entire workflow: requesting reset, using a valid token, using an expired/invalid token, and successfully resetting the password. Verify email sending mechanism."
          },
          {
            "id": 6,
            "title": "Integrate Role-Based Access Control (RBAC) Middleware",
            "description": "Develop and integrate middleware to enforce role-based access control on various API endpoints.",
            "dependencies": [],
            "details": "Create a middleware function that checks the authenticated user's role against a list of required roles for a specific route. Apply this middleware to protected routes (e.g., admin-only endpoints). Deny access with an appropriate HTTP status code (e.g., 403 Forbidden) if the user's role is insufficient.",
            "status": "pending",
            "testStrategy": "Integration tests for various user roles (e.g., admin, regular user) attempting to access protected and unprotected endpoints. Verify correct access/denial based on role. Test with unauthenticated requests."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Admin Setup Module",
        "description": "Develop the Admin Setup Module for managing core school data.",
        "details": "1.  Design the Admin Setup Module UI. 2.  Implement the bulk import of Student and Teacher data from a CSV template. 3.  Implement the Timetable management interface. 4.  Implement the creation and management of staff login credentials.",
        "testStrategy": "Test the CSV import functionality. Verify that new teacher accounts can be created and managed.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design User Database Schema",
            "description": "Define the database table structure for storing user information, including fields for username, email, password hash, and roles.",
            "dependencies": [],
            "details": "Create a `users` table with columns: `id` (PK, auto-increment), `username` (unique, string), `email` (unique, string), `password_hash` (string), `created_at` (timestamp), `updated_at` (timestamp). Consider indexing `username` and `email` for performance.",
            "status": "pending",
            "testStrategy": "Verify table creation and column definitions using a database client (e.g., psql, MySQL Workbench). Insert dummy data to ensure schema integrity."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to register by providing a username, email, and password. The password should be hashed before storage.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Validate input for uniqueness of username/email and password strength. Use a strong hashing algorithm (e.g., bcrypt) for passwords. Store the hashed password in the database.",
            "status": "pending",
            "testStrategy": "Use Postman/cURL to send valid registration requests, invalid requests (e.g., missing fields, duplicate username/email, weak password). Verify user creation in the database and appropriate error responses."
          },
          {
            "id": 3,
            "title": "Develop JWT Generation and Verification Utility",
            "description": "Create a set of utility functions for generating, signing, and verifying JSON Web Tokens.",
            "dependencies": [],
            "details": "Implement functions like `generateToken(payload, secret, expiresIn)` and `verifyToken(token, secret)`. The payload should include user ID and roles. Define a secure secret key and an appropriate expiration time for tokens.",
            "status": "pending",
            "testStrategy": "Write unit tests for each utility function: ensure tokens are generated correctly with the given payload, verify valid tokens, and confirm that invalid or expired tokens are rejected."
          },
          {
            "id": 4,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint (`/api/login`) that authenticates users based on their username/email and password, returning a JWT upon successful login.",
            "dependencies": [],
            "details": "Develop a POST endpoint. Retrieve user by username/email. Compare provided password with stored hash. If credentials are valid, generate a JWT using the utility function and return it in the response body.",
            "status": "pending",
            "testStrategy": "Use Postman/cURL to send valid login requests (verify JWT generation) and invalid requests (e.g., wrong password, non-existent user). Check for correct JWT structure and appropriate error messages."
          },
          {
            "id": 5,
            "title": "Implement JWT Authentication Middleware",
            "description": "Create a middleware function that protects API routes by verifying the presence and validity of a JWT in the request header.",
            "dependencies": [],
            "details": "The middleware should extract the token from the `Authorization: Bearer <token>` header. Use the JWT verification utility. If valid, decode the token and attach the user payload (e.g., user ID, roles) to the request object. If invalid or missing, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Apply the middleware to a dummy protected route. Test access with a valid JWT, an invalid JWT, an expired JWT, and no JWT. Verify that authenticated requests proceed and unauthenticated ones are rejected with the correct status code."
          },
          {
            "id": 6,
            "title": "Create a Protected API Route Example",
            "description": "Implement a simple API endpoint that requires authentication using the developed JWT middleware to demonstrate its functionality.",
            "dependencies": [],
            "details": "Create a GET endpoint (e.g., `/api/profile`) that returns basic user information (e.g., username, email) retrieved from the request object (populated by the middleware). This route should only be accessible to authenticated users.",
            "status": "pending",
            "testStrategy": "Perform an authenticated request to `/api/profile` using a JWT obtained from the login endpoint. Verify that user data is returned. Perform an unauthenticated request to the same endpoint and confirm it returns a 401 Unauthorized error."
          }
        ]
      },
      {
        "id": 7,
        "title": "Design and Implement Data Model in Supabase",
        "description": "Define and implement the database schema in Supabase.",
        "details": "1.  Design the database schema for Students, Teachers, Classes, Timetables, AttendanceRecords, and Notices. 2.  Create tables in Supabase based on the data model. 3.  Implement relationships between tables.",
        "testStrategy": "Verify that the database schema is correctly implemented and that the relationships between tables are established.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project and Install Dependencies",
            "description": "Set up a new Node.js project and install all required packages for building a user authentication system.",
            "dependencies": [],
            "details": "Use `npm init -y` to create `package.json`. Install core dependencies: `express`, `bcryptjs` (for password hashing), `jsonwebtoken` (for JWTs), `dotenv` (for environment variables), and `mongoose` (for database interaction). Configure basic server structure and database connection.",
            "status": "pending",
            "testStrategy": "Verify `package.json` contains all listed dependencies. Ensure the server starts without errors and connects to the database successfully."
          },
          {
            "id": 2,
            "title": "Implement User Registration Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to sign up, securely hashing their passwords before saving them to the database.",
            "dependencies": [],
            "details": "Define a Mongoose User schema with fields like `username`, `email`, and `password`. Implement a POST `/api/register` route. Before saving, hash the provided password using `bcryptjs.hash()`. Handle potential errors such as duplicate usernames/emails and validation failures. Return a success message or the newly created user (excluding password).",
            "status": "pending",
            "testStrategy": "Use Postman or cURL to send POST requests to `/api/register` with valid user data. Verify that a new user record is created in the database with a hashed password. Test with invalid data (e.g., missing fields, existing username) and assert appropriate error responses."
          },
          {
            "id": 3,
            "title": "Implement User Login Endpoint and JWT Generation",
            "description": "Create an API endpoint (`/api/login`) for user authentication, verifying credentials and issuing a JSON Web Token (JWT) upon successful login.",
            "dependencies": [],
            "details": "Implement a POST `/api/login` route. Find the user by their provided username/email. Compare the provided password with the stored hashed password using `bcryptjs.compare()`. If credentials are valid, generate a JWT using `jsonwebtoken.sign()` including the user's ID and a secret key. Return the generated JWT to the client.",
            "status": "pending",
            "testStrategy": "Use Postman or cURL to send POST requests to `/api/login` with correct and incorrect credentials. Verify that a valid JWT is returned for successful logins and appropriate error messages (e.g., 'Invalid credentials') for failed attempts. Ensure the JWT payload contains the user ID."
          },
          {
            "id": 4,
            "title": "Develop JWT Authentication Middleware",
            "description": "Create a middleware function that verifies the presence and validity of a JWT in the request header for protecting API routes.",
            "dependencies": [],
            "details": "Create a middleware function (e.g., `authMiddleware.js`). This middleware should extract the token from the `Authorization` header (e.g., 'Bearer TOKEN'). Use `jsonwebtoken.verify()` to validate the token against the secret key. If valid, decode the token, attach the user's ID (from the token payload) to the `req` object (e.g., `req.user = { id: decoded.id }`), and call `next()`. Handle cases where the token is missing, invalid, or expired by sending appropriate HTTP error responses (e.g., 401 Unauthorized, 403 Forbidden).",
            "status": "pending",
            "testStrategy": "Test the middleware by attempting to access a protected route (to be created in subtask 5) with no token, an invalid token, and a valid token. Ensure correct access is granted only with a valid token and appropriate error responses are returned otherwise."
          },
          {
            "id": 5,
            "title": "Create a Sample Protected Route",
            "description": "Implement a simple API endpoint that can only be accessed by authenticated users, demonstrating the functionality of the JWT authentication middleware.",
            "dependencies": [],
            "details": "Create a GET `/api/profile` or `/api/dashboard` route. Apply the `authMiddleware` created in subtask 4 to this route. The route handler should access `req.user.id` (populated by the middleware) to demonstrate that the user's identity is available after authentication. Return some user-specific data or a simple success message.",
            "status": "pending",
            "testStrategy": "Use Postman or cURL. Attempt to access `/api/profile` without a token (should result in 401/403). Attempt with an invalid token (should result in 401/403). Obtain a valid token from `/api/login` and use it to access `/api/profile` (should succeed and return the expected data, confirming `req.user` is populated)."
          }
        ]
      },
      {
        "id": 8,
        "title": "Integrate SMS Gateway API",
        "description": "Integrate the SMS Gateway API for sending absence alerts.",
        "details": "1.  Choose an SMS Gateway API provider. 2.  Implement the API integration to send SMS messages to parents when a student is marked absent. 3.  Test the SMS sending functionality.",
        "testStrategy": "Verify that SMS messages are sent successfully to the parents of absent students.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for Users",
            "description": "Define the database table structure for storing user information, including fields for username, email, password hash, salt, and roles.",
            "dependencies": [],
            "details": "Create a `users` table with columns: `id (PK, UUID)`, `username (VARCHAR UNIQUE)`, `email (VARCHAR UNIQUE)`, `password_hash (VARCHAR)`, `password_salt (VARCHAR)`, `created_at (TIMESTAMP)`, `updated_at (TIMESTAMP)`, `is_active (BOOLEAN DEFAULT TRUE)`. Consider indexing `username` and `email` for performance.",
            "status": "pending",
            "testStrategy": "Review schema definition with the team lead and database administrator. Ensure all required fields are present, data types are appropriate, and constraints (e.g., UNIQUE) are correctly applied."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create an API endpoint (`/api/register`) that allows new users to sign up by providing a username, email, and password. This endpoint should handle input validation, password hashing, and storing user data in the database.",
            "dependencies": [],
            "details": "Use `POST /api/register`. Implement robust input validation for username (min/max length, allowed characters), email (format), and password (min length, complexity requirements). Use a strong, industry-standard hashing algorithm (e.g., bcrypt) for password hashing, generating a unique salt for each user. Store the hashed password and salt in the database. Return a success message or appropriate error codes (e.g., 400 for bad input, 409 for existing user).",
            "status": "pending",
            "testStrategy": "Develop unit tests for input validation logic, password hashing, and database insertion. Create integration tests for the endpoint, covering valid registrations, invalid inputs (e.g., weak password, invalid email), and attempts to register with an already existing username/email. Verify database entries for newly registered users."
          },
          {
            "id": 3,
            "title": "Develop JWT Token Generation and Validation Utilities",
            "description": "Create utility functions for generating JSON Web Tokens (JWTs) upon successful login and for validating incoming JWTs for protected routes.",
            "dependencies": [],
            "details": "Utilize a standard JWT library (e.g., `jsonwebtoken` in Node.js, `PyJWT` in Python). Implement `generateToken(payload, secret, options)` to create signed tokens with user-specific data (e.g., user ID, roles, expiration time). Implement `verifyToken(token, secret)` to decode and validate tokens, checking signature and expiration. Define the JWT secret key as an environment variable.",
            "status": "pending",
            "testStrategy": "Write unit tests for token generation (verify payload correctness, expiration time). Test token validation with valid tokens, expired tokens, tokens with invalid signatures, and malformed tokens. Ensure appropriate errors or exceptions are raised for invalid tokens."
          },
          {
            "id": 4,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint (`/api/login`) that authenticates users based on their username/email and password, returning an authentication token upon successful login.",
            "dependencies": [],
            "details": "Use `POST /api/login`. Accept username/email and password. Retrieve the user's record from the database. Compare the provided password with the stored hashed password using the stored salt. If credentials are valid, use the utility from subtask 3 to generate a JWT token. Return the JWT token in the response body (e.g., as a bearer token). Handle invalid credentials with a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Develop unit tests for password verification logic. Create integration tests for the endpoint, covering successful logins with correct credentials, failed logins with incorrect passwords, and failed logins with non-existent users. Verify that a valid JWT is returned on success and appropriate error codes are returned on failure."
          },
          {
            "id": 5,
            "title": "Integrate Authentication Middleware for Protected Routes",
            "description": "Implement middleware that uses the JWT validation utility to protect specific API routes, ensuring only authenticated users with valid tokens can access them.",
            "dependencies": [],
            "details": "Create an `authMiddleware` function. This middleware should extract the JWT from the `Authorization` header (e.g., 'Bearer <token>'). Use the `verifyToken` utility from subtask 3 to validate the token. If valid, decode the token's payload and attach relevant user information (e.g., `req.user = decoded_payload`) to the request object for subsequent route handlers. If the token is missing, invalid, or expired, return a 401 Unauthorized or 403 Forbidden error. Apply this middleware to at least one sample protected route (e.g., `/api/profile`).",
            "status": "pending",
            "testStrategy": "Create integration tests for a protected route: attempt access with a valid token, an expired token, an invalid token, and no token. Verify that access is granted only with a valid token and that appropriate HTTP status codes (e.g., 200, 401, 403) are returned in other scenarios. Ensure user information is correctly attached to the request object when authenticated."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Offline Support",
        "description": "Implement offline support for the application.",
        "details": "1.  Implement caching for the last loaded timetable and notices. 2.  Allow the attendance module to work offline and auto-sync when connectivity is restored.",
        "testStrategy": "Test the application's behavior when offline. Verify that the timetable and notices are displayed correctly and that attendance data is saved and synced when connectivity is restored.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for User Management",
            "description": "Define the database tables and fields required to store user information, including authentication credentials and profile data.",
            "dependencies": [],
            "details": "Create `users` table with fields: `id` (PK), `username` (unique), `email` (unique), `password_hash`, `salt`, `created_at`, `updated_at`, `is_active`. Consider indexing `username` and `email`.",
            "status": "pending",
            "testStrategy": "Review DDL for correctness and completeness. Execute DDL on a test database and verify table and column creation."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop an API endpoint that allows new users to register by providing a username, email, and password, storing their hashed credentials securely.",
            "dependencies": [],
            "details": "Endpoint: `POST /api/auth/register`. Validate input (email format, password strength). Hash password using bcrypt with a generated salt. Store user data in the `users` table. Return a success message or appropriate error.",
            "status": "pending",
            "testStrategy": "Use Postman/cURL to test with valid and invalid inputs (missing fields, duplicate username/email, weak password). Verify user creation in the database and appropriate HTTP status codes."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint",
            "description": "Create an API endpoint for users to authenticate with their credentials and receive a JSON Web Token (JWT) upon successful login.",
            "dependencies": [],
            "details": "Endpoint: `POST /api/auth/login`. Validate input (username/email, password). Retrieve user from DB. Compare provided password with stored hash using bcrypt. If valid, generate a JWT containing user ID and roles. Return the JWT.",
            "status": "pending",
            "testStrategy": "Test with valid credentials, invalid password, non-existent user. Verify JWT structure and content for successful logins. Check for appropriate error responses (e.g., 401 Unauthorized)."
          },
          {
            "id": 4,
            "title": "Develop JWT Generation and Validation Utilities",
            "description": "Create helper functions or a service for generating, signing, and verifying JSON Web Tokens.",
            "dependencies": [],
            "details": "Implement functions: `generateToken(payload, secret, expiresIn)` and `verifyToken(token, secret)`. Use a robust JWT library. Ensure the secret key is loaded from environment variables and is sufficiently complex.",
            "status": "pending",
            "testStrategy": "Unit tests for `generateToken` with various payloads. Unit tests for `verifyToken` with valid, invalid, expired, and tampered tokens. Ensure correct error handling for verification failures."
          },
          {
            "id": 5,
            "title": "Implement JWT Authentication Middleware",
            "description": "Create a middleware function that protects API routes by validating the JWT provided in the request header.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization: Bearer <token>` header. Use the `verifyToken` utility. If valid, decode the payload and attach user information (e.g., `req.user`) to the request object. If invalid or missing, return a 401 Unauthorized response.",
            "status": "pending",
            "testStrategy": "Create a dummy protected route. Test access with a valid JWT, an expired JWT, an invalid JWT, and no JWT. Verify that valid tokens grant access and invalid/missing tokens result in 401."
          },
          {
            "id": 6,
            "title": "Implement Protected User Profile Endpoint",
            "description": "Develop a simple API endpoint that returns the authenticated user's profile information, accessible only after successful JWT authentication.",
            "dependencies": [],
            "details": "Endpoint: `GET /api/user/profile`. Apply the JWT authentication middleware to this route. Retrieve user details from the `req.user` object populated by the middleware (e.g., username, email). Return these details.",
            "status": "pending",
            "testStrategy": "Access the endpoint using a valid JWT obtained from the login endpoint. Access without a JWT. Access with an invalid/expired JWT. Verify that the correct user data is returned for authenticated requests and 401 for unauthenticated ones."
          }
        ]
      },
      {
        "id": 10,
        "title": "Testing, Deployment, and Documentation",
        "description": "Comprehensive testing, deployment, and documentation.",
        "details": "1.  Conduct thorough testing of all features. 2.  Deploy the frontend to Vercel/Netlify. 3.  Set up a CI/CD pipeline for automated deployments. 4.  Create user documentation and training materials.",
        "testStrategy": "Perform end-to-end testing of all features. Verify that the application is deployed correctly and that the documentation is accurate.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for Users and Sessions",
            "description": "Define the database tables, columns, data types, and relationships for storing user accounts and active session tokens.",
            "dependencies": [],
            "details": "Create a 'users' table (id, username, email, password_hash, created_at, updated_at) and a 'sessions' table (id, user_id, token, expires_at, created_at). Ensure appropriate indexing for performance on common lookup fields (username, email, session token).",
            "status": "pending",
            "testStrategy": "Review schema with team members for correctness, normalization, and potential performance bottlenecks. Verify all necessary fields are present and data types are suitable."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Develop a RESTful API endpoint to handle new user registrations, including input validation and secure password hashing.",
            "dependencies": [],
            "details": "Create a POST /api/register endpoint. It should accept username, email, and password. Validate email format, username uniqueness, and password strength. Hash the password using a strong, modern algorithm (e.g., bcrypt) before storing it in the 'users' table. Return appropriate success/error responses.",
            "status": "pending",
            "testStrategy": "Unit tests for input validation (valid/invalid email, short password, existing username). Integration tests for the endpoint with successful registration and various failure scenarios (e.g., duplicate email, weak password)."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint",
            "description": "Develop a RESTful API endpoint for user authentication, verifying credentials and issuing a secure session token.",
            "dependencies": [],
            "details": "Create a POST /api/login endpoint. It should accept username/email and password. Verify the provided password against the stored hash. If credentials are valid, generate a unique, expiring session token and store it in the 'sessions' table linked to the user_id. Return the session token to the client.",
            "status": "pending",
            "testStrategy": "Unit tests for password comparison logic and token generation. Integration tests for the endpoint with correct credentials, incorrect password, non-existent user, and ensuring a valid token is returned on success."
          },
          {
            "id": 4,
            "title": "Develop Session Authentication Middleware",
            "description": "Create a middleware component to protect API routes by validating incoming session tokens and attaching user context to requests.",
            "dependencies": [],
            "details": "The middleware should extract the session token from the request header (e.g., 'Authorization: Bearer <token>'). It must then look up the token in the 'sessions' table, verify its validity (not expired), and retrieve the associated user data. If valid, attach the user object to the request (e.g., req.user) and call next(). If invalid or missing, return a 401 Unauthorized response.",
            "status": "pending",
            "testStrategy": "Unit tests for token parsing, expiration checks, and database lookup. Integration tests by applying the middleware to a dummy protected route, testing with valid, expired, invalid, and missing tokens."
          },
          {
            "id": 5,
            "title": "Implement User Profile Retrieval API Endpoint",
            "description": "Create a protected API endpoint that allows an authenticated user to retrieve their own profile information.",
            "dependencies": [],
            "details": "Create a GET /api/profile endpoint. This endpoint must be protected by the session authentication middleware (Subtask 4). It should use the user information attached to the request by the middleware to fetch and return non-sensitive profile data (e.g., username, email, created_at) from the 'users' table.",
            "status": "pending",
            "testStrategy": "Integration tests to ensure only authenticated users can access this endpoint. Test with valid tokens to verify correct user data is returned, and with invalid/missing tokens to confirm 401 responses."
          },
          {
            "id": 6,
            "title": "Implement User Logout API Endpoint",
            "description": "Develop a protected API endpoint that invalidates the current user's active session token.",
            "dependencies": [],
            "details": "Create a POST /api/logout endpoint. This endpoint must be protected by the session authentication middleware. It should use the session token from the request (or the user_id from the authenticated request context) to mark the corresponding session in the 'sessions' table as expired or delete it entirely. Return a success message.",
            "status": "pending",
            "testStrategy": "Integration tests to ensure that after a successful logout, subsequent requests using the invalidated token result in a 401 Unauthorized response. Test edge cases like attempting to log out an already expired or non-existent session."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-23T01:44:01.237Z",
      "updated": "2025-09-23T01:44:01.237Z",
      "description": "Tasks for the attendance and SMS feature."
    }
  },
  "frontend-rebuild": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Initialization and Setup",
        "description": "Initialize the frontend project with Vite, React, and Tailwind CSS, and set up the basic deployment pipeline.",
        "details": "1.  Use Vite to create a new React project: `npm create vite@latest kataria-school-frontend --template react`. 2.  Navigate to the project directory: `cd kataria-school-frontend`. 3.  Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer`. 4.  Generate `tailwind.config.js` and `postcss.config.js`: `npx tailwindcss init -p`. 5.  Configure Tailwind CSS in `tailwind.config.js` to include template paths. 6.  Add Tailwind directives to your `index.css` or `global.css` file. 7.  Set up a basic deployment pipeline on Vercel or Netlify by connecting the repository.",
        "testStrategy": "Verify that the project builds successfully and that Tailwind CSS styles are applied correctly. Test deployment by deploying a basic 'Hello World' component.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Vite React Project",
            "description": "Create a new React project using Vite and navigate into its directory to establish the foundational project structure.",
            "dependencies": [],
            "details": "Use the command `npm create vite@latest kataria-school-frontend --template react` to create the project. Subsequently, navigate into the created project directory using `cd kataria-school-frontend`.",
            "status": "done",
            "testStrategy": "Verify that the `kataria-school-frontend` directory is created with a basic Vite/React project structure, including `package.json`, `index.html`, and `src` folder. Run `npm install` and `npm run dev` to ensure the development server starts without errors."
          },
          {
            "id": 2,
            "title": "Integrate and Configure Tailwind CSS",
            "description": "Install Tailwind CSS and its necessary dependencies, generate the configuration files, and correctly set up Tailwind directives within the project's stylesheet.",
            "dependencies": [
              1
            ],
            "details": "Install dependencies: `npm install -D tailwindcss postcss autoprefixer`. Generate `tailwind.config.js` and `postcss.config.js` using `npx tailwindcss init -p`. Configure `tailwind.config.js` to include template paths (e.g., `content: [\"./index.html\", \"./src/**/*.{js,ts,jsx,tsx}\"]`). Add Tailwind directives (`@tailwind base; @tailwind components; @tailwind utilities;`) to `src/index.css`.",
            "status": "done",
            "testStrategy": "Run the development server (`npm run dev`). Create a simple React component and apply Tailwind utility classes (e.g., `text-blue-500`, `p-4`, `bg-gray-100`). Verify that these styles are correctly applied in the browser, indicating successful integration."
          },
          {
            "id": 3,
            "title": "Set Up Basic Deployment Pipeline (Vercel/Netlify)",
            "description": "Establish a continuous deployment pipeline for the frontend project by connecting the project's Git repository to either Vercel or Netlify.",
            "dependencies": [
              1,
              2
            ],
            "details": "Initialize a Git repository in the project root, commit the current project setup, and push the code to a remote Git hosting service (e.g., GitHub). Log in to Vercel or Netlify, create a new project, and connect it to the remote Git repository. Ensure the build command and output directory are correctly configured (Vite typically defaults to `npm run build` and `dist`).",
            "status": "done",
            "testStrategy": "Trigger a deployment from the chosen platform (Vercel/Netlify). After deployment, access the provided URL to ensure the application loads correctly. Verify that the initial Vite/React 'Hello World' page is displayed and that any applied Tailwind styles from subtask 2 are visible."
          }
        ]
      },
      {
        "id": 2,
        "title": "Component File Structure and Core Layout",
        "description": "Establish the component-based file structure and build the Header and Footer components.",
        "details": "1.  Create a component directory (e.g., `src/components`). 2.  Create subdirectories for different component types (e.g., `src/components/layout`, `src/components/ui`, `src/components/sections`). 3.  Create `Header.jsx` and `Footer.jsx` components within the `layout` directory. 4.  Implement the `Header` component with the school logo, navigation links, and social media icons. 5.  Implement the `Footer` component with quick links and contact information. 6.  Use Tailwind CSS for styling.",
        "testStrategy": "Verify that the Header and Footer components render correctly and that the navigation links and social media icons are displayed as expected. Check responsiveness across different screen sizes.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Create Base Component Directory Structure",
            "description": "Create the main `src/components` directory and its subdirectories (`layout`, `ui`, `sections`) to organize different types of UI components, following best practices for a scalable project structure.",
            "dependencies": [],
            "details": "Create `src/components` directory. Inside `src/components`, create `layout`, `ui`, and `sections` subdirectories. This foundational step is crucial for component organization before creating specific components.",
            "status": "done",
            "testStrategy": "Verify the existence of `src/components` and its subdirectories (`layout`, `ui`, `sections`) in the project file system upon completion."
          },
          {
            "id": 2,
            "title": "Develop Header Component Core Structure and Basic Styling",
            "description": "Create the `Header.jsx` file within the `layout` directory and implement its core JSX structure, applying initial Tailwind CSS classes for basic layout and branding elements like the school logo placeholder.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/layout/Header.jsx`. Implement the main `nav` element and placeholder `div` elements for the logo, navigation links, and social media icons. Apply basic Tailwind CSS classes for structure and initial visual separation.",
            "status": "done",
            "testStrategy": "Render the `Header` component in a development environment. Visually inspect that the basic HTML structure is present and initial styling (e.g., background color, padding, display flex) is correctly applied via Tailwind CSS."
          },
          {
            "id": 3,
            "title": "Implement Header Component Content and Full Responsiveness",
            "description": "Integrate the school logo, actual navigation links, and social media icons into the `Header` component. Ensure full responsiveness across various screen sizes using Tailwind CSS utility classes, including considerations for a mobile-friendly navigation.",
            "dependencies": [
              2
            ],
            "details": "Add `img` tag for the school logo, `ul/li/a` elements for navigation links, and appropriate icons/links for social media. Implement responsive design using Tailwind's breakpoints (e.g., `sm:`, `md:`, `lg:` classes) to adapt the layout. Consider implementing a mobile menu (hamburger icon) for smaller screens.",
            "status": "done",
            "testStrategy": "Verify that the Header renders correctly across desktop, tablet, and mobile breakpoints using browser developer tools. Check that the logo, navigation links, and social media icons are visible, clickable, and correctly styled on all devices. Test mobile navigation functionality if implemented."
          },
          {
            "id": 4,
            "title": "Develop Footer Component Content and Full Responsiveness",
            "description": "Create the `Footer.jsx` file within the `layout` directory and implement the quick links and contact information. Ensure the Footer component is fully responsive, adapting its layout for optimal display on all screen sizes using Tailwind CSS.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/layout/Footer.jsx`. Implement sections for quick links (e.g., `ul/li/a` for categories like 'About', 'Contact') and contact information (e.g., address, phone, email, copyright notice). Apply Tailwind CSS utility classes to achieve a responsive layout, adjusting element stacking and spacing for mobile, tablet, and desktop views.",
            "status": "done",
            "testStrategy": "Verify that the Footer renders correctly across desktop, tablet, and mobile breakpoints using browser developer tools. Check that quick links and contact information are visible, correctly formatted, and clickable. Ensure elements stack appropriately and spacing is correct on smaller screens."
          }
        ]
      },
      {
        "id": 3,
        "title": "UI Component Library: Button, Card, Input",
        "description": "Create reusable UI components: Button, Card, and Input fields.",
        "details": "1.  Create a `ui` directory inside the `components` directory. 2.  Create `Button.jsx`, `Card.jsx`, and `Input.jsx` components. 3.  Implement the `Button` component with primary and secondary variants. 4.  Implement the `Card` component for displaying content. 5.  Implement the `Input` component for form fields. 6.  Style these components using Tailwind CSS, adhering to the reference design.",
        "testStrategy": "Test each component to ensure it renders correctly and responds to user interactions (e.g., button clicks, input focus). Verify the different variants and styles.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up UI directory and implement Button component with variants",
            "description": "Create the `ui` directory within `src/components` if it doesn't already exist, and implement the `Button.jsx` component. This includes defining primary and secondary visual variants and applying responsive Tailwind CSS styles according to the reference design.",
            "dependencies": [],
            "details": "1. Verify/create `src/components/ui` directory. 2. Create `Button.jsx` inside `src/components/ui`. 3. Define the Button component structure, accepting props like `onClick`, `children`, and `variant` ('primary', 'secondary'). 4. Implement conditional Tailwind CSS classes based on the `variant` prop to apply distinct styles for primary and secondary buttons (e.g., background color, text color, hover states, padding, border-radius). 5. Ensure the component is reusable and accessible.",
            "status": "done",
            "testStrategy": "Verify that the Button component renders correctly with both 'primary' and 'secondary' variants. Test click events and ensure hover/focus styles are applied as per design. Check responsiveness."
          },
          {
            "id": 2,
            "title": "Implement reusable Card component",
            "description": "Create the `Card.jsx` component within the `src/components/ui` directory. The component should be designed for displaying flexible content, styled with Tailwind CSS to match the reference design, and ensure reusability.",
            "dependencies": [
              1
            ],
            "details": "1. Create `Card.jsx` inside `src/components/ui`. 2. Define the Card component structure, accepting `children` prop for content, and potentially props for header or footer slots. 3. Apply responsive Tailwind CSS classes for background color, border, shadow, padding, and border-radius, adhering to the reference design. 4. Ensure the component provides a clean container for various types of content.",
            "status": "done",
            "testStrategy": "Verify that the Card component renders correctly with different types and amounts of content. Test its visual appearance (background, border, shadow) and responsiveness across various screen sizes."
          },
          {
            "id": 3,
            "title": "Implement reusable Input component",
            "description": "Create the `Input.jsx` component within the `src/components/ui` directory. This component will serve as a reusable form field, incorporating standard HTML input attributes and styled consistently with Tailwind CSS according to the design specifications.",
            "dependencies": [
              1
            ],
            "details": "1. Create `Input.jsx` inside `src/components/ui`. 2. Define the Input component structure, accepting standard HTML input attributes such as `type`, `placeholder`, `value`, `onChange`, `name`, and `id`. 3. Apply responsive Tailwind CSS classes for consistent styling, including padding, border, text color, focus states, and potential error states, adhering to the reference design. 4. Implement basic accessibility features like `aria-label` or `htmlFor` if used with a label.",
            "status": "done",
            "testStrategy": "Verify that the Input component renders correctly for different `type` attributes (e.g., text, email, password). Test input functionality, focus/blur events, and ensure visual consistency for active and inactive states. Check responsiveness."
          }
        ]
      },
      {
        "id": 4,
        "title": "Hero Section Implementation",
        "description": "Develop the Hero section component for the main landing view.",
        "details": "1.  Create a `Hero.jsx` component inside the `sections` directory. 2.  Implement the Hero section with the school's name and primary heading. 3.  Use Tailwind CSS for styling, ensuring it matches the reference design. 4.  Consider adding a background image or video.",
        "testStrategy": "Verify that the Hero section displays the correct content and styling. Test responsiveness across different screen sizes.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Hero.jsx Component File",
            "description": "Create the basic React component file for the Hero section within the 'sections' directory.",
            "dependencies": [],
            "details": "Create a new file named `Hero.jsx` inside the `src/components/sections` directory. Define a functional React component named `Hero` that returns a basic JSX structure (e.g., a div).",
            "status": "done",
            "testStrategy": "Verify that the `Hero.jsx` file exists in the correct directory and can be imported without errors."
          },
          {
            "id": 2,
            "title": "Implement Primary Content (School Name and Heading)",
            "description": "Add the school's name and the primary heading text to the Hero section component.",
            "dependencies": [
              1
            ],
            "details": "Inside the `Hero` component, add `h1` and `p` tags to display the school's name and the main catchy heading for the landing page. Use placeholder text initially.",
            "status": "done",
            "testStrategy": "Render the `Hero` component in a test environment or storybook and visually confirm the presence of the school name and main heading."
          },
          {
            "id": 3,
            "title": "Apply Desktop Tailwind CSS Styling",
            "description": "Style the Hero section for desktop view using Tailwind CSS to match the reference design.",
            "dependencies": [
              2
            ],
            "details": "Apply Tailwind CSS classes to the Hero component's elements (container, text, etc.) to define layout, typography, colors, padding, and margins for larger screens, ensuring it aligns with the design specification.",
            "status": "done",
            "testStrategy": "Visually inspect the Hero section on a desktop browser to ensure styling (font sizes, colors, spacing, alignment) matches the design. Use browser developer tools."
          },
          {
            "id": 4,
            "title": "Implement Responsive Styling for Mobile/Tablet",
            "description": "Adjust the Hero section's Tailwind CSS styling to ensure optimal display on mobile and tablet devices.",
            "dependencies": [
              3
            ],
            "details": "Utilize Tailwind's responsive prefixes (e.g., `sm:`, `md:`, `lg:`) to modify layout, font sizes, padding, and alignment for smaller screen sizes. Ensure content remains readable and well-formatted.",
            "status": "done",
            "testStrategy": "Test the Hero section on various screen sizes using browser developer tools' responsive mode or actual devices to confirm correct rendering and responsiveness."
          },
          {
            "id": 5,
            "title": "Integrate Background Image or Video",
            "description": "Add a suitable background image or video to the Hero section as per design requirements.",
            "dependencies": [
              4
            ],
            "details": "Implement the background for the Hero section. This could involve using a `div` with a `background-image` CSS property or embedding a video element, ensuring it's responsive and covers the section appropriately.",
            "status": "done",
            "testStrategy": "Visually verify that the background image or video loads correctly, displays without distortion, and remains responsive across different screen sizes. Check for performance impact."
          }
        ]
      },
      {
        "id": 5,
        "title": "About Section Implementation",
        "description": "Develop the About section component to display information about the school.",
        "details": "1.  Create an `About.jsx` component inside the `sections` directory. 2.  Implement the About section with relevant information about the school. 3.  Use Tailwind CSS for styling, ensuring it matches the reference design.",
        "testStrategy": "Verify that the About section displays the correct content and styling. Test responsiveness across different screen sizes.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create About.jsx component file",
            "description": "Create the `About.jsx` file in the `src/sections` directory and set up a basic React functional component export.",
            "dependencies": [],
            "details": "Create the file `src/sections/About.jsx`. Define a functional React component named `About` and export it as default. Include a basic `div` with a placeholder text like 'About Section Content' for initial rendering.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement basic About section content structure",
            "description": "Add the foundational HTML structure for the About section, including headings, paragraphs for textual information about the school, and potential image placeholders, without extensive styling.",
            "dependencies": [
              1
            ],
            "details": "Inside `About.jsx`, add an `h2` for the section title (e.g., 'About Our School'), multiple `p` tags for descriptive text, and an `img` tag with a placeholder `src` and `alt` attribute if the design includes an image.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Apply core Tailwind CSS for layout and typography",
            "description": "Use Tailwind CSS classes to style the main layout of the About section, including overall spacing, text alignment, font sizes, and basic color themes, adhering to the reference design.",
            "dependencies": [
              2
            ],
            "details": "Apply Tailwind classes to the main container for padding (e.g., `p-8`, `py-16`), text elements for font size (e.g., `text-3xl`, `text-lg`), font weight (`font-bold`), text color (`text-gray-800`), and basic layout (`flex`, `flex-col`, `items-center`).",
            "status": "done",
            "testStrategy": "Visually verify that the basic layout, overall spacing, and typography (font sizes, colors) of the About section match the provided reference design for a desktop view."
          },
          {
            "id": 4,
            "title": "Refine styling and ensure responsiveness with Tailwind",
            "description": "Enhance the About section's visual design with more specific Tailwind classes, including responsive breakpoints (e.g., `md:`, `lg:`), adding details like shadows, borders, rounded corners, and ensuring it renders correctly on various screen sizes.",
            "dependencies": [
              3
            ],
            "details": "Introduce responsive utility classes (e.g., `md:flex-row`, `lg:w-1/2`, `md:text-left`) for different screen sizes. Apply more detailed styling such as `shadow-lg`, `rounded-xl`, specific background colors (`bg-white`), and gap between elements (`gap-8`).",
            "status": "done",
            "testStrategy": "Test responsiveness by resizing the browser window and using developer tools across different device emulations (small, medium, large screens). Verify consistent and correct appearance across all breakpoints according to the design."
          },
          {
            "id": 5,
            "title": "Integrate actual school information and final review",
            "description": "Replace all placeholder text and image sources with the actual information and assets about the school. Perform a comprehensive final review of the component's visual accuracy, content correctness, and overall functionality.",
            "dependencies": [
              4
            ],
            "details": "Update the `h2` and `p` tags with the actual school name, mission, vision, or general description. Replace placeholder `img` `src` attributes with paths to actual school images. Conduct a thorough visual comparison against the final design mockups, checking for any discrepancies, typos, or broken elements.",
            "status": "done",
            "testStrategy": "Verify that all content displayed is accurate, complete, and free of errors as per the official school information. Conduct a final pixel-perfect visual inspection and responsiveness check across various devices to ensure full adherence to the design specifications."
          }
        ]
      },
      {
        "id": 6,
        "title": "Mission/Vision Section Implementation",
        "description": "Build the three-column layout for the school's mission, vision, and values.",
        "details": "1.  Create a `MissionVision.jsx` component inside the `sections` directory. 2.  Implement the three-column layout for the mission, vision, and values. 3.  Use Tailwind CSS for styling, ensuring it matches the reference design.",
        "testStrategy": "Verify that the Mission/Vision section displays the correct content and styling. Test responsiveness across different screen sizes.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MissionVision.jsx component file",
            "description": "Create the React component file for the Mission/Vision section in the 'sections' directory, ready for content.",
            "dependencies": [],
            "details": "Create a new file named `MissionVision.jsx` within the `src/sections` directory. Inside, define and export a basic functional React component structure.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement main section container and heading",
            "description": "Set up the main container for the Mission/Vision section within the component and add a descriptive section heading.",
            "dependencies": [
              1
            ],
            "details": "Inside the `MissionVision.jsx` component, add a parent `div` or semantic `section` element. Include a `h2` tag for the section title (e.g., 'Our Mission, Vision & Values') and apply initial Tailwind CSS for basic spacing and text styling.",
            "status": "pending",
            "testStrategy": "Visually confirm the section heading is rendered on the page with correct initial styling. Check for appropriate vertical spacing."
          },
          {
            "id": 3,
            "title": "Develop three-column layout structure",
            "description": "Create the HTML and apply Tailwind CSS for a responsive three-column layout within the Mission/Vision section to hold the individual mission, vision, and values content.",
            "dependencies": [
              2
            ],
            "details": "Within the main section container, implement a three-column layout using Tailwind CSS grid (e.g., `grid grid-cols-1 md:grid-cols-3 gap-8`). Ensure the layout stacks vertically on smaller screens and transitions to three columns on larger screens.",
            "status": "pending",
            "testStrategy": "Inspect the rendered HTML structure to verify the three-column grid is correctly applied. Resize the browser to confirm responsiveness: columns should stack on small screens and go side-by-side on larger screens."
          },
          {
            "id": 4,
            "title": "Populate content for Mission, Vision, Values",
            "description": "Add placeholder content (headings and paragraphs) for the Mission, Vision, and Values into their respective columns, and apply initial text styling.",
            "dependencies": [
              3
            ],
            "details": "Inside each of the three columns created in the previous step, add a distinct heading (e.g., 'Mission', 'Vision', 'Values') and a paragraph of placeholder text. Apply basic Tailwind typography classes for font size, weight, and color.",
            "status": "pending",
            "testStrategy": "Verify that distinct placeholder content (headings and text) is visible in each of the three columns. Check for consistent and readable text styling."
          },
          {
            "id": 5,
            "title": "Refine styling and ensure responsiveness",
            "description": "Apply final Tailwind CSS styling to all elements within the Mission/Vision section to precisely match the reference design, and conduct thorough responsiveness testing.",
            "dependencies": [
              4
            ],
            "details": "Adjust all Tailwind CSS classes (padding, margins, font styles, colors, backgrounds, borders, shadows, etc.) to ensure the section's appearance is pixel-perfect to the design. Test layout, text wrapping, and element scaling across various breakpoints (mobile, tablet, desktop) using browser developer tools to ensure full responsiveness.",
            "status": "pending",
            "testStrategy": "Perform a comprehensive visual review comparing the implemented section against the design mockups on different screen sizes (using browser dev tools). Confirm all styling elements, spacing, and responsiveness behave as expected."
          }
        ]
      },
      {
        "id": 7,
        "title": "Principal's Message Section Implementation",
        "description": "Create the Principal's Message section component.",
        "details": "1.  Create a `PrincipalMessage.jsx` component inside the `sections` directory. 2.  Implement the Principal's Message section, including the principal's photo and message. 3.  Use Tailwind CSS for styling, ensuring it matches the reference design.",
        "testStrategy": "Verify that the Principal's Message section displays the correct content and styling. Test responsiveness across different screen sizes.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PrincipalMessage component file",
            "description": "Create the `PrincipalMessage.jsx` file in the `src/sections` directory and set up a basic functional React component structure.",
            "dependencies": [],
            "details": "Create `src/sections/PrincipalMessage.jsx` with a boilerplate React functional component definition: `const PrincipalMessage = () => { return <div>Principal's Message Section</div>; }; export default PrincipalMessage;`",
            "status": "pending",
            "testStrategy": "Verify the file exists at the specified path and exports a functional component without any compilation errors."
          },
          {
            "id": 2,
            "title": "Add principal's photo display",
            "description": "Integrate the principal's photo into the `PrincipalMessage` component, ensuring it's properly imported and displayed within an `<img>` tag.",
            "dependencies": [
              1
            ],
            "details": "Inside `PrincipalMessage.jsx`, add an `<img>` tag. Use a placeholder image or a path to the actual principal's photo. Ensure appropriate alt text is provided for accessibility.",
            "status": "pending",
            "testStrategy": "Visually verify that the principal's photo is displayed within the component. Check image source and alt text."
          },
          {
            "id": 3,
            "title": "Add principal's message text content",
            "description": "Integrate the principal's message text content into the `PrincipalMessage` component, ensuring proper semantic HTML elements (e.g., `<p>`, `<h2>`) are used.",
            "dependencies": [
              2
            ],
            "details": "Add the principal's message text, including any headings and paragraphs, into the `PrincipalMessage.jsx` component. Use placeholder text initially if the final content is not available.",
            "status": "pending",
            "testStrategy": "Visually verify that the principal's message text is displayed and structured correctly within the component. Check for any missing content."
          },
          {
            "id": 4,
            "title": "Apply Tailwind CSS styling for layout and appearance",
            "description": "Apply Tailwind CSS classes to the `PrincipalMessage` component to match the layout, typography, colors, and spacing specified in the reference design.",
            "dependencies": [
              3
            ],
            "details": "Use Tailwind CSS utility classes to style the main container, the image, and the text elements (e.g., font sizes, colors, margins, padding, flexbox for layout). Ensure the overall design matches the visual mockups.",
            "status": "pending",
            "testStrategy": "Visually compare the component's styling against the reference design. Verify correct spacing, alignment, font styles, colors, and overall layout. Use browser dev tools to inspect applied styles."
          },
          {
            "id": 5,
            "title": "Ensure responsiveness and final component review",
            "description": "Adjust styling for various screen sizes using Tailwind's responsive utilities and conduct a final review of the component's content and styling.",
            "dependencies": [
              4
            ],
            "details": "Apply responsive Tailwind CSS classes (e.g., `sm:`, `md:`, `lg:`) to ensure the `PrincipalMessage` section adapts gracefully to different screen sizes. Perform a final check for content accuracy, adherence to design, and overall component integrity.",
            "status": "pending",
            "testStrategy": "Test responsiveness across different screen sizes (e.g., using browser developer tools' responsive mode). Verify content and styling remain consistent and visually appealing on mobile, tablet, and desktop views."
          }
        ]
      },
      {
        "id": 8,
        "title": "Testimonials Section Implementation",
        "description": "Develop a dynamic section to display parent testimonials, potentially in a carousel.",
        "details": "1.  Create a `Testimonials.jsx` component inside the `sections` directory. 2.  Implement the Testimonials section. Consider using a carousel library (e.g., Swiper.js) for dynamic display. 3.  Use Tailwind CSS for styling, ensuring it matches the reference design.",
        "testStrategy": "Verify that the Testimonials section displays the correct content and styling. Test responsiveness across different screen sizes. Test the carousel functionality.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Research and Select Carousel Library for Testimonials",
            "description": "Investigate suitable JavaScript carousel libraries, comparing features, ease of integration, bundle size, and compatibility with React and Tailwind CSS. Recommend and select the best option (e.g., Swiper.js, React-Slick) based on project needs and performance considerations.",
            "dependencies": [],
            "details": "Evaluate Swiper.js, React-Slick, and other relevant libraries based on their documentation, community support, accessibility features, and performance. Document the chosen library and the key reasons for its selection, considering future maintainability and ease of use.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Develop Testimonials Component and Integrate Chosen Carousel Library",
            "description": "Create the `Testimonials.jsx` component inside the `sections` directory. Install the selected carousel library and integrate it into the component, displaying static testimonial data initially to verify basic functionality and library setup.",
            "dependencies": [
              1
            ],
            "details": "Create the file `src/sections/Testimonials.jsx`. Set up the basic React component structure. Install the chosen carousel library using npm or yarn (e.g., `npm install swiper`). Implement the carousel with at least 3-5 static testimonial items, ensuring it renders without errors and its basic navigation works.",
            "status": "pending",
            "testStrategy": "Verify that the `Testimonials.jsx` component renders successfully and the chosen carousel library is integrated correctly, displaying static content in a basic carousel structure without console errors."
          },
          {
            "id": 3,
            "title": "Populate Dynamic Content, Apply Styling, and Ensure Responsiveness",
            "description": "Replace static testimonial data with dynamic content (e.g., from a mock API or local data structure). Apply Tailwind CSS styling to match the reference design for the testimonials and the carousel elements. Ensure the carousel is fully responsive across various screen sizes and orientations.",
            "dependencies": [
              2
            ],
            "details": "Define a local array of testimonial objects or simulate fetching data. Map this data to the carousel slides. Use Tailwind CSS classes to style individual testimonial cards (text, images, author, ratings if any) and customize the carousel's navigation (arrows, pagination). Configure the carousel library for optimal responsiveness and touch gesture support.",
            "status": "pending",
            "testStrategy": "Verify that dynamic testimonial content is displayed correctly within the carousel. Confirm that all styling adheres to the reference design. Test carousel navigation (swiping, clicks on arrows/pagination). Test responsiveness thoroughly by resizing the browser window, using browser developer tools for various device emulations, and on actual mobile devices if possible."
          }
        ]
      },
      {
        "id": 9,
        "title": "Enquiry Form Section Implementation",
        "description": "Build the detailed enquiry form as a standalone component.",
        "details": "1.  Create an `EnquiryForm.jsx` component inside the `sections` directory. 2.  Implement the enquiry form with the required fields. 3.  Add client-side validation to the form. 4.  Use Tailwind CSS for styling, ensuring it matches the reference design. 5.  Prepare the form for future integration with Supabase (placeholder for now).",
        "testStrategy": "Verify that the enquiry form displays correctly. Test client-side validation. Test the form submission (ensure no errors).",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Enquiry Form Component & Define Fields",
            "description": "Set up the `EnquiryForm.jsx` component inside the `sections` directory, define all required input fields (e.g., name, email, subject, message), and arrange them with a basic HTML structure.",
            "dependencies": [],
            "details": "Create `EnquiryForm.jsx` in the `sections` directory. Use `<form>`, `<input>`, `<textarea>`, `<button>` elements. Ensure appropriate `type` and `name` attributes for each field. Include labels for accessibility.",
            "status": "pending",
            "testStrategy": "Verify the component renders on a test page without errors. Ensure all intended form fields (input, textarea, button) are present and visible in the DOM."
          },
          {
            "id": 2,
            "title": "Implement Form State Management and Change Handlers",
            "description": "Establish React state management (e.g., using `useState`) to capture and update form field values as users interact with the inputs. Prepare for the form's submission data.",
            "dependencies": [
              1
            ],
            "details": "Use `useState` hooks for each input field or a single object state to manage form data. Implement `onChange` event handlers for all input fields to update the component's state. Create a placeholder `handleSubmit` function.",
            "status": "pending",
            "testStrategy": "Input data into various fields and use React DevTools or console logs to confirm that the component's internal state accurately reflects the entered values."
          },
          {
            "id": 3,
            "title": "Add Client-Side Form Validation Logic",
            "description": "Develop and integrate robust client-side validation for all form fields, including checks for required fields, valid email format, and appropriate message length. Display informative error messages to the user.",
            "dependencies": [
              2
            ],
            "details": "Create a validation function (e.g., `validateForm`) that runs on blur or submission. Store validation error messages in component state. Conditionally render error messages next to their respective input fields.",
            "status": "pending",
            "testStrategy": "Test various scenarios: submitting an empty form, invalid email, short/long messages, and confirm that correct error messages appear. Verify errors clear upon valid input."
          },
          {
            "id": 4,
            "title": "Apply Tailwind CSS for Form Styling",
            "description": "Apply Tailwind CSS utility classes to all elements of the enquiry form (inputs, textarea, labels, buttons, and error messages) to match the specified design reference and ensure responsiveness.",
            "dependencies": [
              1,
              3
            ],
            "details": "Use Tailwind classes for layout (e.g., flexbox, grid, spacing), typography, borders, backgrounds, and interactive states (e.g., hover, focus) on all form elements. Ensure consistency with the overall site design.",
            "status": "pending",
            "testStrategy": "Visually inspect the form in a browser to ensure it matches the design mockups. Test responsiveness across different screen sizes and devices to confirm proper layout and styling."
          }
        ]
      },
      {
        "id": 10,
        "title": "Interactivity and State Management",
        "description": "Implement mobile navigation, smooth scrolling, and state management for the enquiry form.",
        "details": "1.  Implement the logic for the mobile navigation menu (hamburger menu) in the `Header` component. 2.  Implement smooth-scrolling for on-page navigation links. 3.  Manage the state for the enquiry form (e.g., using React's `useState` hook).",
        "testStrategy": "Test the mobile navigation menu. Test smooth scrolling. Test the enquiry form state management.",
        "priority": "medium",
        "dependencies": [
          2,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Mobile Navigation Toggle and Menu Styling",
            "description": "Develop the logic for toggling the mobile navigation menu (hamburger menu) within the Header component, including its open/close states and corresponding visual styling for responsiveness.",
            "dependencies": [],
            "details": "Create state for mobile menu visibility (e.g., `isOpen` boolean). Implement a click handler for the hamburger icon to toggle this state. Conditionally render or apply CSS classes to the navigation menu based on `isOpen`. Use Tailwind CSS to style the hamburger icon animation (e.g., transform to 'X') and the slide-in/out effect of the menu.",
            "status": "pending",
            "testStrategy": "Verify the hamburger icon toggles the menu on mobile viewports. Check menu opens/closes smoothly. Ensure menu content is accessible when open and hidden when closed. Test responsiveness across different mobile screen sizes."
          },
          {
            "id": 2,
            "title": "Implement Smooth Scrolling for On-Page Navigation Links",
            "description": "Add smooth scrolling functionality to all internal navigation links that point to different sections of the page, ensuring a fluid user experience.",
            "dependencies": [],
            "details": "Identify all anchor links within the navigation that target specific sections (e.g., '#about', '#contact'). Apply `scroll-behavior: smooth;` to the root HTML element or use a JavaScript approach (e.g., `window.scrollTo` with `behavior: 'smooth'`) when a navigation link is clicked to smoothly scroll to the target section ID.",
            "status": "pending",
            "testStrategy": "Click each internal navigation link and verify that the page smoothly scrolls to the corresponding section. Ensure the target section is correctly aligned in the viewport after scrolling. Test on both desktop and mobile devices."
          },
          {
            "id": 3,
            "title": "Implement Enquiry Form State Management Logic",
            "description": "Develop the state management logic for the enquiry form, handling user input for each field and storing it efficiently.",
            "dependencies": [
              3
            ],
            "details": "Integrate the `Input` component (from Task 3) into the enquiry form. Use React's `useState` hook to manage the state of each form field (e.g., name, email, message). Create a single state object for the form data. Implement `onChange` handlers for all input fields to update the respective state values as the user types.",
            "status": "pending",
            "testStrategy": "Fill out each field in the enquiry form and verify that the component's internal state correctly updates with the entered values. Console log the form state to confirm data integrity upon changes. Ensure no data is lost upon re-renders."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-29T14:02:29.537Z",
      "updated": "2025-10-29T15:07:23.980Z",
      "description": "Tasks for frontend-rebuild context"
    }
  }
}